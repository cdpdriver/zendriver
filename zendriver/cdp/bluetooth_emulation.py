# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: BluetoothEmulation (experimental)

from __future__ import annotations

import enum
import typing
from dataclasses import dataclass, field

from .util import event_type


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


class CentralState(enum.Enum):
    """
    Indicates the various states of Central.
    """

    ABSENT = 'absent'
    POWERED_OFF = 'powered-off'
    POWERED_ON = 'powered-on'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CentralState:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> CentralState | None:
        if json is None:
            return None
        return cls.from_json(json)


class GATTOperationType(enum.Enum):
    """
    Indicates the various types of GATT event.
    """

    CONNECTION = 'connection'
    DISCOVERY = 'discovery'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> GATTOperationType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> GATTOperationType | None:
        if json is None:
            return None
        return cls.from_json(json)


class CharacteristicWriteType(enum.Enum):
    """
    Indicates the various types of characteristic write.
    """

    WRITE_DEFAULT_DEPRECATED = 'write-default-deprecated'
    WRITE_WITH_RESPONSE = 'write-with-response'
    WRITE_WITHOUT_RESPONSE = 'write-without-response'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CharacteristicWriteType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> CharacteristicWriteType | None:
        if json is None:
            return None
        return cls.from_json(json)


class CharacteristicOperationType(enum.Enum):
    """
    Indicates the various types of characteristic operation.
    """

    READ = 'read'
    WRITE = 'write'
    SUBSCRIBE_TO_NOTIFICATIONS = 'subscribe-to-notifications'
    UNSUBSCRIBE_FROM_NOTIFICATIONS = 'unsubscribe-from-notifications'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CharacteristicOperationType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> CharacteristicOperationType | None:
        if json is None:
            return None
        return cls.from_json(json)


class DescriptorOperationType(enum.Enum):
    """
    Indicates the various types of descriptor operation.
    """

    READ = 'read'
    WRITE = 'write'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> DescriptorOperationType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> DescriptorOperationType | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ManufacturerData:
    """
    Stores the manufacturer data
    """

    #: Company identifier
    #: https://bitbucket.org/bluetooth-SIG/public/src/main/assigned_numbers/company_identifiers/company_identifiers.yaml
    #: https://usb.org/developers
    key: int

    #: Manufacturer-specific data (Encoded as a base64 string when passed over JSON)
    data: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['key'] = self.key
        json['data'] = self.data
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ManufacturerData:
        return cls(
            key=int(json['key']),
            data=str(json['data']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ManufacturerData | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ScanRecord:
    """
    Stores the byte data of the advertisement packet sent by a Bluetooth device.
    """

    name: str | None = None

    uuids: list[str] = field(default_factory=list)

    #: Stores the external appearance description of the device.
    appearance: int | None = None

    #: Stores the transmission power of a broadcasting device.
    tx_power: int | None = None

    #: Key is the company identifier and the value is an array of bytes of
    #: manufacturer specific data.
    manufacturer_data: list[ManufacturerData] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.name is not None:
            json['name'] = self.name
        if self.uuids is not None:
            json['uuids'] = self.uuids
        if self.appearance is not None:
            json['appearance'] = self.appearance
        if self.tx_power is not None:
            json['txPower'] = self.tx_power
        if self.manufacturer_data is not None:
            json['manufacturerData'] = [i.to_json() for i in self.manufacturer_data]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScanRecord:
        return cls(
            name=None if json.get('name') is None else str(json['name']),
            uuids=[str(i) for i in json.get('uuids', [])],
            appearance=None if json.get('appearance') is None else int(json['appearance']),
            tx_power=None if json.get('txPower') is None else int(json['txPower']),
            manufacturer_data=[ManufacturerData.from_json(i) for i in json.get('manufacturerData', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ScanRecord | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ScanEntry:
    """
    Stores the advertisement packet information that is sent by a Bluetooth device.
    """

    device_address: str

    rssi: int

    scan_record: ScanRecord

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['deviceAddress'] = self.device_address
        json['rssi'] = self.rssi
        json['scanRecord'] = self.scan_record.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScanEntry:
        return cls(
            device_address=str(json['deviceAddress']),
            rssi=int(json['rssi']),
            scan_record=ScanRecord.from_json(json['scanRecord']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ScanEntry | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CharacteristicProperties:
    """
    Describes the properties of a characteristic. This follows Bluetooth Core
    Specification BT 4.2 Vol 3 Part G 3.3.1. Characteristic Properties.
    """

    broadcast: bool | None = None

    read: bool | None = None

    write_without_response: bool | None = None

    write: bool | None = None

    notify: bool | None = None

    indicate: bool | None = None

    authenticated_signed_writes: bool | None = None

    extended_properties: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.broadcast is not None:
            json['broadcast'] = self.broadcast
        if self.read is not None:
            json['read'] = self.read
        if self.write_without_response is not None:
            json['writeWithoutResponse'] = self.write_without_response
        if self.write is not None:
            json['write'] = self.write
        if self.notify is not None:
            json['notify'] = self.notify
        if self.indicate is not None:
            json['indicate'] = self.indicate
        if self.authenticated_signed_writes is not None:
            json['authenticatedSignedWrites'] = self.authenticated_signed_writes
        if self.extended_properties is not None:
            json['extendedProperties'] = self.extended_properties
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CharacteristicProperties:
        return cls(
            broadcast=None if json.get('broadcast') is None else bool(json['broadcast']),
            read=None if json.get('read') is None else bool(json['read']),
            write_without_response=None
            if json.get('writeWithoutResponse') is None
            else bool(json['writeWithoutResponse']),
            write=None if json.get('write') is None else bool(json['write']),
            notify=None if json.get('notify') is None else bool(json['notify']),
            indicate=None if json.get('indicate') is None else bool(json['indicate']),
            authenticated_signed_writes=None
            if json.get('authenticatedSignedWrites') is None
            else bool(json['authenticatedSignedWrites']),
            extended_properties=None if json.get('extendedProperties') is None else bool(json['extendedProperties']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CharacteristicProperties | None:
        if json is None:
            return None
        return cls.from_json(json)


def enable(
    state: CentralState,
    *,
    le_supported: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enable the BluetoothEmulation domain.

    :param state: State of the simulated central.
    :param le_supported: If the simulated central supports low-energy.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['state'] = state.to_json()
    params['leSupported'] = le_supported
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.enable',
        'params': params,
    }
    json = yield cmd_dict


def set_simulated_central_state(
    state: CentralState,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Set the state of the simulated central.

    :param state: State of the simulated central.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['state'] = state.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.setSimulatedCentralState',
        'params': params,
    }
    json = yield cmd_dict


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disable the BluetoothEmulation domain.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.disable',
    }
    json = yield cmd_dict


def simulate_preconnected_peripheral(
    address: str,
    name: str,
    manufacturer_data: list[ManufacturerData],
    known_service_uuids: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates a peripheral with ``address``, ``name`` and ``knownServiceUuids``
    that has already been connected to the system.

    :param address:
    :param name:
    :param manufacturer_data:
    :param known_service_uuids:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['address'] = address
    params['name'] = name
    params['manufacturerData'] = [i.to_json() for i in manufacturer_data]
    params['knownServiceUuids'] = known_service_uuids
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulatePreconnectedPeripheral',
        'params': params,
    }
    json = yield cmd_dict


def simulate_advertisement(
    entry: ScanEntry,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates an advertisement packet described in ``entry`` being received by
    the central.

    :param entry:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['entry'] = entry.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulateAdvertisement',
        'params': params,
    }
    json = yield cmd_dict


def simulate_gatt_operation_response(
    address: str,
    type_: GATTOperationType,
    code: int,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates the response code from the peripheral with ``address`` for a
    GATT operation of ``type``. The ``code`` value follows the HCI Error Codes from
    Bluetooth Core Specification Vol 2 Part D 1.3 List Of Error Codes.

    :param address:
    :param type_:
    :param code:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['address'] = address
    params['type'] = type_.to_json()
    params['code'] = code
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulateGATTOperationResponse',
        'params': params,
    }
    json = yield cmd_dict


def simulate_characteristic_operation_response(
    characteristic_id: str,
    type_: CharacteristicOperationType,
    code: int,
    *,
    data: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates the response from the characteristic with ``characteristicId`` for a
    characteristic operation of ``type``. The ``code`` value follows the Error
    Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response.
    The ``data`` is expected to exist when simulating a successful read operation
    response.

    :param characteristic_id:
    :param type_:
    :param code:
    :param data: *(Optional)*
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['characteristicId'] = characteristic_id
    params['type'] = type_.to_json()
    params['code'] = code
    if data is not None:
        params['data'] = data
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulateCharacteristicOperationResponse',
        'params': params,
    }
    json = yield cmd_dict


def simulate_descriptor_operation_response(
    descriptor_id: str,
    type_: DescriptorOperationType,
    code: int,
    *,
    data: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates the response from the descriptor with ``descriptorId`` for a
    descriptor operation of ``type``. The ``code`` value follows the Error
    Codes from Bluetooth Core Specification Vol 3 Part F 3.4.1.1 Error Response.
    The ``data`` is expected to exist when simulating a successful read operation
    response.

    :param descriptor_id:
    :param type_:
    :param code:
    :param data: *(Optional)*
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['descriptorId'] = descriptor_id
    params['type'] = type_.to_json()
    params['code'] = code
    if data is not None:
        params['data'] = data
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulateDescriptorOperationResponse',
        'params': params,
    }
    json = yield cmd_dict


def add_service(
    address: str,
    service_uuid: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Adds a service with ``serviceUuid`` to the peripheral with ``address``.

    :param address:
    :param service_uuid:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, str]
    """

    params: T_JSON_DICT = {}
    params['address'] = address
    params['serviceUuid'] = service_uuid
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.addService',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['serviceId'])


def remove_service(
    service_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Removes the service respresented by ``serviceId`` from the simulated central.

    :param service_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['serviceId'] = service_id
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.removeService',
        'params': params,
    }
    json = yield cmd_dict


def add_characteristic(
    service_id: str,
    characteristic_uuid: str,
    properties: CharacteristicProperties,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Adds a characteristic with ``characteristicUuid`` and ``properties`` to the
    service represented by ``serviceId``.

    :param service_id:
    :param characteristic_uuid:
    :param properties:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, str]
    """

    params: T_JSON_DICT = {}
    params['serviceId'] = service_id
    params['characteristicUuid'] = characteristic_uuid
    params['properties'] = properties.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.addCharacteristic',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['characteristicId'])


def remove_characteristic(
    characteristic_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Removes the characteristic respresented by ``characteristicId`` from the
    simulated central.

    :param characteristic_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['characteristicId'] = characteristic_id
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.removeCharacteristic',
        'params': params,
    }
    json = yield cmd_dict


def add_descriptor(
    characteristic_id: str,
    descriptor_uuid: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Adds a descriptor with ``descriptorUuid`` to the characteristic respresented
    by ``characteristicId``.

    :param characteristic_id:
    :param descriptor_uuid:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, str]
    """

    params: T_JSON_DICT = {}
    params['characteristicId'] = characteristic_id
    params['descriptorUuid'] = descriptor_uuid
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.addDescriptor',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['descriptorId'])


def remove_descriptor(
    descriptor_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Removes the descriptor with ``descriptorId`` from the simulated central.

    :param descriptor_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['descriptorId'] = descriptor_id
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.removeDescriptor',
        'params': params,
    }
    json = yield cmd_dict


def simulate_gatt_disconnection(
    address: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulates a GATT disconnection from the peripheral with ``address``.

    :param address:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['address'] = address
    cmd_dict: T_JSON_DICT = {
        'method': 'BluetoothEmulation.simulateGATTDisconnection',
        'params': params,
    }
    json = yield cmd_dict


@event_type('BluetoothEmulation.gattOperationReceived')
@dataclass
class GattOperationReceived:
    """
    Event for when a GATT operation of ``type`` to the peripheral with ``address``
    happened.
    """

    address: str
    type_: GATTOperationType

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> GattOperationReceived:
        return cls(
            address=str(json['address']),
            type_=GATTOperationType.from_json(json['type']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> GattOperationReceived | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('BluetoothEmulation.characteristicOperationReceived')
@dataclass
class CharacteristicOperationReceived:
    """
    Event for when a characteristic operation of ``type`` to the characteristic
    respresented by ``characteristicId`` happened. ``data`` and ``writeType`` is
    expected to exist when ``type`` is write.
    """

    characteristic_id: str
    type_: CharacteristicOperationType
    data: str | None
    write_type: CharacteristicWriteType | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CharacteristicOperationReceived:
        return cls(
            characteristic_id=str(json['characteristicId']),
            type_=CharacteristicOperationType.from_json(json['type']),
            data=None if json.get('data') is None else str(json['data']),
            write_type=CharacteristicWriteType.from_json_optional(json.get('writeType')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CharacteristicOperationReceived | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('BluetoothEmulation.descriptorOperationReceived')
@dataclass
class DescriptorOperationReceived:
    """
    Event for when a descriptor operation of ``type`` to the descriptor
    respresented by ``descriptorId`` happened. ``data`` is expected to exist when
    ``type`` is write.
    """

    descriptor_id: str
    type_: DescriptorOperationType
    data: str | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DescriptorOperationReceived:
        return cls(
            descriptor_id=str(json['descriptorId']),
            type_=DescriptorOperationType.from_json(json['type']),
            data=None if json.get('data') is None else str(json['data']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DescriptorOperationReceived | None:
        if json is None:
            return None
        return cls.from_json(json)
