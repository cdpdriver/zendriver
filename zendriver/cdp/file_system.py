# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: FileSystem (experimental)

from __future__ import annotations

import typing
from dataclasses import dataclass

from . import network, storage


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


@dataclass
class File:
    name: str

    #: Timestamp
    last_modified: network.TimeSinceEpoch

    #: Size in bytes
    size: float

    type_: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['lastModified'] = self.last_modified.to_json()
        json['size'] = self.size
        json['type'] = self.type_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> File:
        return cls(
            name=str(json['name']),
            last_modified=network.TimeSinceEpoch.from_json(json['lastModified']),
            size=float(json['size']),
            type_=str(json['type']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> File | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Directory:
    name: str

    nested_directories: list[str]

    #: Files that are directly nested under this directory.
    nested_files: list[File]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['nestedDirectories'] = self.nested_directories
        json['nestedFiles'] = [i.to_json() for i in self.nested_files]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Directory:
        return cls(
            name=str(json['name']),
            nested_directories=[str(i) for i in json.get('nestedDirectories', [])],
            nested_files=[File.from_json(i) for i in json.get('nestedFiles', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Directory | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class BucketFileSystemLocator:
    #: Storage key
    storage_key: storage.SerializedStorageKey

    #: Path to the directory using each path component as an array item.
    path_components: list[str]

    #: Bucket name. Not passing a ``bucketName`` will retrieve the default Bucket. (https://developer.mozilla.org/en-US/docs/Web/API/Storage_API#storage_buckets)
    bucket_name: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['storageKey'] = self.storage_key.to_json()
        json['pathComponents'] = self.path_components
        if self.bucket_name is not None:
            json['bucketName'] = self.bucket_name
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BucketFileSystemLocator:
        return cls(
            storage_key=storage.SerializedStorageKey.from_json(json['storageKey']),
            path_components=[str(i) for i in json.get('pathComponents', [])],
            bucket_name=None if json.get('bucketName') is None else str(json['bucketName']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> BucketFileSystemLocator | None:
        if json is None:
            return None
        return cls.from_json(json)


def get_directory(
    bucket_file_system_locator: BucketFileSystemLocator,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Directory]:
    """
    :param bucket_file_system_locator:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, Directory]
    """

    params: T_JSON_DICT = {}
    params['bucketFileSystemLocator'] = bucket_file_system_locator.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'FileSystem.getDirectory',
        'params': params,
    }
    json = yield cmd_dict
    return Directory.from_json(json['directory'])
