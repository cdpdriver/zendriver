# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: IndexedDB (experimental)

from __future__ import annotations

import typing
from dataclasses import dataclass, field

from . import runtime


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from . import storage
    from .util import T_JSON_DICT


@dataclass
class DatabaseWithObjectStores:
    """
    Database with an array of object stores.
    """

    #: Database name.
    name: str

    #: Database version (type is not 'integer', as the standard
    #: requires the version number to be 'unsigned long long')
    version: float

    #: Object stores in this database.
    object_stores: list[ObjectStore]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['version'] = self.version
        json['objectStores'] = [i.to_json() for i in self.object_stores]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DatabaseWithObjectStores:
        return cls(
            name=str(json['name']),
            version=float(json['version']),
            object_stores=[ObjectStore.from_json(i) for i in json.get('objectStores', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DatabaseWithObjectStores | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ObjectStore:
    """
    Object store.
    """

    #: Object store name.
    name: str

    #: Object store key path.
    key_path: KeyPath

    #: If true, object store has auto increment flag set.
    auto_increment: bool

    #: Indexes in this object store.
    indexes: list[ObjectStoreIndex]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['keyPath'] = self.key_path.to_json()
        json['autoIncrement'] = self.auto_increment
        json['indexes'] = [i.to_json() for i in self.indexes]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ObjectStore:
        return cls(
            name=str(json['name']),
            key_path=KeyPath.from_json(json['keyPath']),
            auto_increment=bool(json['autoIncrement']),
            indexes=[ObjectStoreIndex.from_json(i) for i in json.get('indexes', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ObjectStore | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ObjectStoreIndex:
    """
    Object store index.
    """

    #: Index name.
    name: str

    #: Index key path.
    key_path: KeyPath

    #: If true, index is unique.
    unique: bool

    #: If true, index allows multiple entries for a key.
    multi_entry: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['keyPath'] = self.key_path.to_json()
        json['unique'] = self.unique
        json['multiEntry'] = self.multi_entry
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ObjectStoreIndex:
        return cls(
            name=str(json['name']),
            key_path=KeyPath.from_json(json['keyPath']),
            unique=bool(json['unique']),
            multi_entry=bool(json['multiEntry']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ObjectStoreIndex | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Key:
    """
    Key.
    """

    #: Key type.
    type_: str

    #: Number value.
    number: float | None = None

    #: String value.
    string: str | None = None

    #: Date value.
    date: float | None = None

    #: Array value.
    array: list[Key] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['type'] = self.type_
        if self.number is not None:
            json['number'] = self.number
        if self.string is not None:
            json['string'] = self.string
        if self.date is not None:
            json['date'] = self.date
        if self.array is not None:
            json['array'] = [i.to_json() for i in self.array]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Key:
        return cls(
            type_=str(json['type']),
            number=None if json.get('number') is None else float(json['number']),
            string=None if json.get('string') is None else str(json['string']),
            date=None if json.get('date') is None else float(json['date']),
            array=[Key.from_json(i) for i in json.get('array', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Key | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class KeyRange:
    """
    Key range.
    """

    #: If true lower bound is open.
    lower_open: bool

    #: If true upper bound is open.
    upper_open: bool

    #: Lower bound.
    lower: Key | None = None

    #: Upper bound.
    upper: Key | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['lowerOpen'] = self.lower_open
        json['upperOpen'] = self.upper_open
        if self.lower is not None:
            json['lower'] = self.lower.to_json()
        if self.upper is not None:
            json['upper'] = self.upper.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> KeyRange:
        return cls(
            lower_open=bool(json['lowerOpen']),
            upper_open=bool(json['upperOpen']),
            lower=Key.from_json_optional(json.get('lower')),
            upper=Key.from_json_optional(json.get('upper')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> KeyRange | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class DataEntry:
    """
    Data entry.
    """

    #: Key object.
    key: runtime.RemoteObject

    #: Primary key object.
    primary_key: runtime.RemoteObject

    #: Value object.
    value: runtime.RemoteObject

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['key'] = self.key.to_json()
        json['primaryKey'] = self.primary_key.to_json()
        json['value'] = self.value.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DataEntry:
        return cls(
            key=runtime.RemoteObject.from_json(json['key']),
            primary_key=runtime.RemoteObject.from_json(json['primaryKey']),
            value=runtime.RemoteObject.from_json(json['value']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DataEntry | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class KeyPath:
    """
    Key path.
    """

    #: Key path type.
    type_: str

    #: String value.
    string: str | None = None

    #: Array value.
    array: list[str] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['type'] = self.type_
        if self.string is not None:
            json['string'] = self.string
        if self.array is not None:
            json['array'] = self.array
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> KeyPath:
        return cls(
            type_=str(json['type']),
            string=None if json.get('string') is None else str(json['string']),
            array=[str(i) for i in json.get('array', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> KeyPath | None:
        if json is None:
            return None
        return cls.from_json(json)


def clear_object_store(
    database_name: str,
    object_store_name: str,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Clears all entries from an object store.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name: Database name.
    :param object_store_name: Object store name.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    params['objectStoreName'] = object_store_name
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.clearObjectStore',
        'params': params,
    }
    json = yield cmd_dict


def delete_database(
    database_name: str,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Deletes a database.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name: Database name.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.deleteDatabase',
        'params': params,
    }
    json = yield cmd_dict


def delete_object_store_entries(
    database_name: str,
    object_store_name: str,
    key_range: KeyRange,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Delete a range of entries from an object store

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name:
    :param object_store_name:
    :param key_range: Range of entry keys to delete
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    params['objectStoreName'] = object_store_name
    params['keyRange'] = key_range.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.deleteObjectStoreEntries',
        'params': params,
    }
    json = yield cmd_dict


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables events from backend.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.disable',
    }
    json = yield cmd_dict


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables events from backend.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.enable',
    }
    json = yield cmd_dict


def request_data(
    database_name: str,
    object_store_name: str,
    skip_count: int,
    page_size: int,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
    index_name: str | None = None,
    key_range: KeyRange | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DataEntry], bool]]:
    """
    Requests data from object store or index.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name: Database name.
    :param object_store_name: Object store name.
    :param index_name: *(Optional)* Index name. If not specified, it performs an object store data request.
    :param skip_count: Number of records to skip.
    :param page_size: Number of records to fetch.
    :param key_range: *(Optional)* Key range.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DataEntry], bool]]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    params['objectStoreName'] = object_store_name
    if index_name is not None:
        params['indexName'] = index_name
    params['skipCount'] = skip_count
    params['pageSize'] = page_size
    if key_range is not None:
        params['keyRange'] = key_range.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.requestData',
        'params': params,
    }
    json = yield cmd_dict
    return ([DataEntry.from_json(i) for i in json.get('objectStoreDataEntries', [])], bool(json['hasMore']))


def get_metadata(
    database_name: str,
    object_store_name: str,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float]]:
    """
    Gets metadata of an object store.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name: Database name.
    :param object_store_name: Object store name.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[float, float]]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    params['objectStoreName'] = object_store_name
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.getMetadata',
        'params': params,
    }
    json = yield cmd_dict
    return (float(json['entriesCount']), float(json['keyGeneratorValue']))


def request_database(
    database_name: str,
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, DatabaseWithObjectStores]:
    """
    Requests database with given name in given frame.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :param database_name: Database name.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, DatabaseWithObjectStores]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    params['databaseName'] = database_name
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.requestDatabase',
        'params': params,
    }
    json = yield cmd_dict
    return DatabaseWithObjectStores.from_json(json['databaseWithObjectStores'])


def request_database_names(
    *,
    security_origin: str | None = None,
    storage_key: str | None = None,
    storage_bucket: storage.StorageBucket | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Requests database names for given security origin.

    :param security_origin: *(Optional)* At least and at most one of securityOrigin, storageKey, or storageBucket must be specified. Security origin.
    :param storage_key: *(Optional)* Storage key.
    :param storage_bucket: *(Optional)* Storage bucket. If not specified, it uses the default bucket.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[str]]
    """

    params: T_JSON_DICT = {}
    if security_origin is not None:
        params['securityOrigin'] = security_origin
    if storage_key is not None:
        params['storageKey'] = storage_key
    if storage_bucket is not None:
        params['storageBucket'] = storage_bucket.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'IndexedDB.requestDatabaseNames',
        'params': params,
    }
    json = yield cmd_dict
    return [str(i) for i in json.get('databaseNames', [])]
