# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: Animation (experimental)

from __future__ import annotations

import typing
from dataclasses import dataclass

from . import dom, runtime
from .util import event_type


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


@dataclass
class Animation:
    """
    Animation instance.
    """

    #: ``Animation``'s id.
    id_: str

    #: ``Animation``'s name.
    name: str

    #: ``Animation``'s internal paused state.
    paused_state: bool

    #: ``Animation``'s play state.
    play_state: str

    #: ``Animation``'s playback rate.
    playback_rate: float

    #: ``Animation``'s start time.
    #: Milliseconds for time based animations and
    #: percentage [0 - 100] for scroll driven animations
    #: (i.e. when viewOrScrollTimeline exists).
    start_time: float

    #: ``Animation``'s current time.
    current_time: float

    #: Animation type of ``Animation``.
    type_: str

    #: ``Animation``'s source animation node.
    source: AnimationEffect | None = None

    #: A unique ID for ``Animation`` representing the sources that triggered this CSS
    #: animation/transition.
    css_id: str | None = None

    #: View or scroll timeline
    view_or_scroll_timeline: ViewOrScrollTimeline | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['id'] = self.id_
        json['name'] = self.name
        json['pausedState'] = self.paused_state
        json['playState'] = self.play_state
        json['playbackRate'] = self.playback_rate
        json['startTime'] = self.start_time
        json['currentTime'] = self.current_time
        json['type'] = self.type_
        if self.source is not None:
            json['source'] = self.source.to_json()
        if self.css_id is not None:
            json['cssId'] = self.css_id
        if self.view_or_scroll_timeline is not None:
            json['viewOrScrollTimeline'] = self.view_or_scroll_timeline.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Animation:
        return cls(
            id_=str(json['id']),
            name=str(json['name']),
            paused_state=bool(json['pausedState']),
            play_state=str(json['playState']),
            playback_rate=float(json['playbackRate']),
            start_time=float(json['startTime']),
            current_time=float(json['currentTime']),
            type_=str(json['type']),
            source=AnimationEffect.from_json_optional(json.get('source')),
            css_id=None if json.get('cssId') is None else str(json['cssId']),
            view_or_scroll_timeline=ViewOrScrollTimeline.from_json_optional(json.get('viewOrScrollTimeline')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Animation | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ViewOrScrollTimeline:
    """
    Timeline instance
    """

    #: Orientation of the scroll
    axis: dom.ScrollOrientation

    #: Scroll container node
    source_node_id: dom.BackendNodeId | None = None

    #: Represents the starting scroll position of the timeline
    #: as a length offset in pixels from scroll origin.
    start_offset: float | None = None

    #: Represents the ending scroll position of the timeline
    #: as a length offset in pixels from scroll origin.
    end_offset: float | None = None

    #: The element whose principal box's visibility in the
    #: scrollport defined the progress of the timeline.
    #: Does not exist for animations with ScrollTimeline
    subject_node_id: dom.BackendNodeId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['axis'] = self.axis.to_json()
        if self.source_node_id is not None:
            json['sourceNodeId'] = self.source_node_id.to_json()
        if self.start_offset is not None:
            json['startOffset'] = self.start_offset
        if self.end_offset is not None:
            json['endOffset'] = self.end_offset
        if self.subject_node_id is not None:
            json['subjectNodeId'] = self.subject_node_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ViewOrScrollTimeline:
        return cls(
            axis=dom.ScrollOrientation.from_json(json['axis']),
            source_node_id=dom.BackendNodeId.from_json_optional(json.get('sourceNodeId')),
            start_offset=None if json.get('startOffset') is None else float(json['startOffset']),
            end_offset=None if json.get('endOffset') is None else float(json['endOffset']),
            subject_node_id=dom.BackendNodeId.from_json_optional(json.get('subjectNodeId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ViewOrScrollTimeline | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class AnimationEffect:
    """
    AnimationEffect instance
    """

    #: ``AnimationEffect``'s delay.
    delay: float

    #: ``AnimationEffect``'s end delay.
    end_delay: float

    #: ``AnimationEffect``'s iteration start.
    iteration_start: float

    #: ``AnimationEffect``'s iterations.
    iterations: float

    #: ``AnimationEffect``'s iteration duration.
    #: Milliseconds for time based animations and
    #: percentage [0 - 100] for scroll driven animations
    #: (i.e. when viewOrScrollTimeline exists).
    duration: float

    #: ``AnimationEffect``'s playback direction.
    direction: str

    #: ``AnimationEffect``'s fill mode.
    fill: str

    #: ``AnimationEffect``'s timing function.
    easing: str

    #: ``AnimationEffect``'s target node.
    backend_node_id: dom.BackendNodeId | None = None

    #: ``AnimationEffect``'s keyframes.
    keyframes_rule: KeyframesRule | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['delay'] = self.delay
        json['endDelay'] = self.end_delay
        json['iterationStart'] = self.iteration_start
        json['iterations'] = self.iterations
        json['duration'] = self.duration
        json['direction'] = self.direction
        json['fill'] = self.fill
        json['easing'] = self.easing
        if self.backend_node_id is not None:
            json['backendNodeId'] = self.backend_node_id.to_json()
        if self.keyframes_rule is not None:
            json['keyframesRule'] = self.keyframes_rule.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AnimationEffect:
        return cls(
            delay=float(json['delay']),
            end_delay=float(json['endDelay']),
            iteration_start=float(json['iterationStart']),
            iterations=float(json['iterations']),
            duration=float(json['duration']),
            direction=str(json['direction']),
            fill=str(json['fill']),
            easing=str(json['easing']),
            backend_node_id=dom.BackendNodeId.from_json_optional(json.get('backendNodeId')),
            keyframes_rule=KeyframesRule.from_json_optional(json.get('keyframesRule')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AnimationEffect | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class KeyframesRule:
    """
    Keyframes Rule
    """

    #: List of animation keyframes.
    keyframes: list[KeyframeStyle]

    #: CSS keyframed animation's name.
    name: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['keyframes'] = [i.to_json() for i in self.keyframes]
        if self.name is not None:
            json['name'] = self.name
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> KeyframesRule:
        return cls(
            keyframes=[KeyframeStyle.from_json(i) for i in json.get('keyframes', [])],
            name=None if json.get('name') is None else str(json['name']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> KeyframesRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class KeyframeStyle:
    """
    Keyframe Style
    """

    #: Keyframe's time offset.
    offset: str

    #: ``AnimationEffect``'s timing function.
    easing: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['offset'] = self.offset
        json['easing'] = self.easing
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> KeyframeStyle:
        return cls(
            offset=str(json['offset']),
            easing=str(json['easing']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> KeyframeStyle | None:
        if json is None:
            return None
        return cls.from_json(json)


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables animation domain notifications.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.disable',
    }
    json = yield cmd_dict


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables animation domain notifications.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.enable',
    }
    json = yield cmd_dict


def get_current_time(
    id_: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, float]:
    """
    Returns the current time of the an animation.

    :param id_: Id of animation.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, float]
    """

    params: T_JSON_DICT = {}
    params['id'] = id_
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.getCurrentTime',
        'params': params,
    }
    json = yield cmd_dict
    return float(json['currentTime'])


def get_playback_rate() -> Generator[T_JSON_DICT, T_JSON_DICT, float]:
    """
    Gets the playback rate of the document timeline.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, float]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.getPlaybackRate',
    }
    json = yield cmd_dict
    return float(json['playbackRate'])


def release_animations(
    animations: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Releases a set of animations to no longer be manipulated.

    :param animations: List of animation ids to seek.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['animations'] = animations
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.releaseAnimations',
        'params': params,
    }
    json = yield cmd_dict


def resolve_animation(
    animation_id: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]:
    """
    Gets the remote object of the Animation.

    :param animation_id: Animation id.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, runtime.RemoteObject]
    """

    params: T_JSON_DICT = {}
    params['animationId'] = animation_id
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.resolveAnimation',
        'params': params,
    }
    json = yield cmd_dict
    return runtime.RemoteObject.from_json(json['remoteObject'])


def seek_animations(
    animations: list[str],
    current_time: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Seek a set of animations to a particular time within each animation.

    :param animations: List of animation ids to seek.
    :param current_time: Set the current time of each animation.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['animations'] = animations
    params['currentTime'] = current_time
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.seekAnimations',
        'params': params,
    }
    json = yield cmd_dict


def set_paused(
    animations: list[str],
    *,
    paused: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Sets the paused state of a set of animations.

    :param animations: Animations to set the pause state of.
    :param paused: Paused state to set to.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['animations'] = animations
    params['paused'] = paused
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.setPaused',
        'params': params,
    }
    json = yield cmd_dict


def set_playback_rate(
    playback_rate: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Sets the playback rate of the document timeline.

    :param playback_rate: Playback rate for animations on page
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['playbackRate'] = playback_rate
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.setPlaybackRate',
        'params': params,
    }
    json = yield cmd_dict


def set_timing(
    animation_id: str,
    duration: float,
    delay: float,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Sets the timing of an animation node.

    :param animation_id: Animation id.
    :param duration: Duration of the animation.
    :param delay: Delay of the animation.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['animationId'] = animation_id
    params['duration'] = duration
    params['delay'] = delay
    cmd_dict: T_JSON_DICT = {
        'method': 'Animation.setTiming',
        'params': params,
    }
    json = yield cmd_dict


@event_type('Animation.animationCanceled')
@dataclass
class AnimationCanceled:
    """
    Event for when an animation has been cancelled.
    """

    #: Id of the animation that was cancelled.
    id_: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AnimationCanceled:
        return cls(id_=str(json['id']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AnimationCanceled | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Animation.animationCreated')
@dataclass
class AnimationCreated:
    """
    Event for each animation that has been created.
    """

    #: Id of the animation that was created.
    id_: str

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AnimationCreated:
        return cls(id_=str(json['id']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AnimationCreated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Animation.animationStarted')
@dataclass
class AnimationStarted:
    """
    Event for animation that has been started.
    """

    #: Animation that was started.
    animation: Animation

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AnimationStarted:
        return cls(animation=Animation.from_json(json['animation']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AnimationStarted | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Animation.animationUpdated')
@dataclass
class AnimationUpdated:
    """
    Event for animation that has been updated.
    """

    #: Animation that was updated.
    animation: Animation

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AnimationUpdated:
        return cls(animation=Animation.from_json(json['animation']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AnimationUpdated | None:
        if json is None:
            return None
        return cls.from_json(json)
