# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: WebAudio (experimental)

from __future__ import annotations

import enum
from dataclasses import dataclass
from typing import TYPE_CHECKING

from .util import event_type


if TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


# ruff: noqa: FURB189


class GraphObjectId(str):
    """
    An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
    """

    __slots__ = ()

    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> GraphObjectId:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> GraphObjectId | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'GraphObjectId({super().__repr__()})'


class ContextType(enum.Enum):
    """
    Enum of BaseAudioContext types
    """

    REALTIME = 'realtime'
    OFFLINE = 'offline'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ContextType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> ContextType | None:
        if json is None:
            return None
        return cls.from_json(json)


class ContextState(enum.Enum):
    """
    Enum of AudioContextState from the spec
    """

    SUSPENDED = 'suspended'
    RUNNING = 'running'
    CLOSED = 'closed'
    INTERRUPTED = 'interrupted'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ContextState:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> ContextState | None:
        if json is None:
            return None
        return cls.from_json(json)


class NodeType(str):
    """
    Enum of AudioNode types
    """

    __slots__ = ()

    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> NodeType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> NodeType | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'NodeType({super().__repr__()})'


class ChannelCountMode(enum.Enum):
    """
    Enum of AudioNode::ChannelCountMode from the spec
    """

    CLAMPED_MAX = 'clamped-max'
    EXPLICIT = 'explicit'
    MAX_ = 'max'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ChannelCountMode:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> ChannelCountMode | None:
        if json is None:
            return None
        return cls.from_json(json)


class ChannelInterpretation(enum.Enum):
    """
    Enum of AudioNode::ChannelInterpretation from the spec
    """

    DISCRETE = 'discrete'
    SPEAKERS = 'speakers'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> ChannelInterpretation:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> ChannelInterpretation | None:
        if json is None:
            return None
        return cls.from_json(json)


class ParamType(str):
    """
    Enum of AudioParam types
    """

    __slots__ = ()

    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> ParamType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> ParamType | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'ParamType({super().__repr__()})'


class AutomationRate(enum.Enum):
    """
    Enum of AudioParam::AutomationRate from the spec
    """

    A_RATE = 'a-rate'
    K_RATE = 'k-rate'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> AutomationRate:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> AutomationRate | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ContextRealtimeData:
    """
    Fields in AudioContext that change in real-time.
    """

    #: The current context time in second in BaseAudioContext.
    current_time: float

    #: The time spent on rendering graph divided by render quantum duration,
    #: and multiplied by 100. 100 means the audio renderer reached the full
    #: capacity and glitch may occur.
    render_capacity: float

    #: A running mean of callback interval.
    callback_interval_mean: float

    #: A running variance of callback interval.
    callback_interval_variance: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['currentTime'] = self.current_time
        json['renderCapacity'] = self.render_capacity
        json['callbackIntervalMean'] = self.callback_interval_mean
        json['callbackIntervalVariance'] = self.callback_interval_variance
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ContextRealtimeData:
        return cls(
            current_time=float(json['currentTime']),
            render_capacity=float(json['renderCapacity']),
            callback_interval_mean=float(json['callbackIntervalMean']),
            callback_interval_variance=float(json['callbackIntervalVariance']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ContextRealtimeData | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class BaseAudioContext:
    """
    Protocol object for BaseAudioContext
    """

    context_id: GraphObjectId

    context_type: ContextType

    context_state: ContextState

    #: Platform-dependent callback buffer size.
    callback_buffer_size: float

    #: Number of output channels supported by audio hardware in use.
    max_output_channel_count: float

    #: Context sample rate.
    sample_rate: float

    realtime_data: ContextRealtimeData | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['contextId'] = self.context_id.to_json()
        json['contextType'] = self.context_type.to_json()
        json['contextState'] = self.context_state.to_json()
        json['callbackBufferSize'] = self.callback_buffer_size
        json['maxOutputChannelCount'] = self.max_output_channel_count
        json['sampleRate'] = self.sample_rate
        if self.realtime_data is not None:
            json['realtimeData'] = self.realtime_data.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BaseAudioContext:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            context_type=ContextType.from_json(json['contextType']),
            context_state=ContextState.from_json(json['contextState']),
            callback_buffer_size=float(json['callbackBufferSize']),
            max_output_channel_count=float(json['maxOutputChannelCount']),
            sample_rate=float(json['sampleRate']),
            realtime_data=ContextRealtimeData.from_json_optional(json.get('realtimeData')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> BaseAudioContext | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class AudioListener:
    """
    Protocol object for AudioListener
    """

    listener_id: GraphObjectId

    context_id: GraphObjectId

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['listenerId'] = self.listener_id.to_json()
        json['contextId'] = self.context_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioListener:
        return cls(
            listener_id=GraphObjectId.from_json(json['listenerId']),
            context_id=GraphObjectId.from_json(json['contextId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioListener | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class AudioNode:
    """
    Protocol object for AudioNode
    """

    node_id: GraphObjectId

    context_id: GraphObjectId

    node_type: NodeType

    number_of_inputs: float

    number_of_outputs: float

    channel_count: float

    channel_count_mode: ChannelCountMode

    channel_interpretation: ChannelInterpretation

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['nodeId'] = self.node_id.to_json()
        json['contextId'] = self.context_id.to_json()
        json['nodeType'] = self.node_type.to_json()
        json['numberOfInputs'] = self.number_of_inputs
        json['numberOfOutputs'] = self.number_of_outputs
        json['channelCount'] = self.channel_count
        json['channelCountMode'] = self.channel_count_mode.to_json()
        json['channelInterpretation'] = self.channel_interpretation.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioNode:
        return cls(
            node_id=GraphObjectId.from_json(json['nodeId']),
            context_id=GraphObjectId.from_json(json['contextId']),
            node_type=NodeType.from_json(json['nodeType']),
            number_of_inputs=float(json['numberOfInputs']),
            number_of_outputs=float(json['numberOfOutputs']),
            channel_count=float(json['channelCount']),
            channel_count_mode=ChannelCountMode.from_json(json['channelCountMode']),
            channel_interpretation=ChannelInterpretation.from_json(json['channelInterpretation']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class AudioParam:
    """
    Protocol object for AudioParam
    """

    param_id: GraphObjectId

    node_id: GraphObjectId

    context_id: GraphObjectId

    param_type: ParamType

    rate: AutomationRate

    default_value: float

    min_value: float

    max_value: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['paramId'] = self.param_id.to_json()
        json['nodeId'] = self.node_id.to_json()
        json['contextId'] = self.context_id.to_json()
        json['paramType'] = self.param_type.to_json()
        json['rate'] = self.rate.to_json()
        json['defaultValue'] = self.default_value
        json['minValue'] = self.min_value
        json['maxValue'] = self.max_value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioParam:
        return cls(
            param_id=GraphObjectId.from_json(json['paramId']),
            node_id=GraphObjectId.from_json(json['nodeId']),
            context_id=GraphObjectId.from_json(json['contextId']),
            param_type=ParamType.from_json(json['paramType']),
            rate=AutomationRate.from_json(json['rate']),
            default_value=float(json['defaultValue']),
            min_value=float(json['minValue']),
            max_value=float(json['maxValue']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioParam | None:
        if json is None:
            return None
        return cls.from_json(json)


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables the WebAudio domain and starts sending context lifetime events.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'WebAudio.enable',
    }
    json = yield cmd_dict


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables the WebAudio domain.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'WebAudio.disable',
    }
    json = yield cmd_dict


def get_realtime_data(
    context_id: GraphObjectId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, ContextRealtimeData]:
    """
    Fetch the realtime data from the registered contexts.

    :param context_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, ContextRealtimeData]
    """

    params: T_JSON_DICT = {}
    params['contextId'] = context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'WebAudio.getRealtimeData',
        'params': params,
    }
    json = yield cmd_dict
    return ContextRealtimeData.from_json(json['realtimeData'])


@event_type('WebAudio.contextCreated')
@dataclass
class ContextCreated:
    """
    Notifies that a new BaseAudioContext has been created.
    """

    context: BaseAudioContext

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ContextCreated:
        return cls(context=BaseAudioContext.from_json(json['context']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ContextCreated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.contextWillBeDestroyed')
@dataclass
class ContextWillBeDestroyed:
    """
    Notifies that an existing BaseAudioContext will be destroyed.
    """

    context_id: GraphObjectId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ContextWillBeDestroyed:
        return cls(context_id=GraphObjectId.from_json(json['contextId']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ContextWillBeDestroyed | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.contextChanged')
@dataclass
class ContextChanged:
    """
    Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
    """

    context: BaseAudioContext

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ContextChanged:
        return cls(context=BaseAudioContext.from_json(json['context']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ContextChanged | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioListenerCreated')
@dataclass
class AudioListenerCreated:
    """
    Notifies that the construction of an AudioListener has finished.
    """

    listener: AudioListener

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioListenerCreated:
        return cls(listener=AudioListener.from_json(json['listener']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioListenerCreated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioListenerWillBeDestroyed')
@dataclass
class AudioListenerWillBeDestroyed:
    """
    Notifies that a new AudioListener has been created.
    """

    context_id: GraphObjectId
    listener_id: GraphObjectId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioListenerWillBeDestroyed:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            listener_id=GraphObjectId.from_json(json['listenerId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioListenerWillBeDestroyed | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioNodeCreated')
@dataclass
class AudioNodeCreated:
    """
    Notifies that a new AudioNode has been created.
    """

    node: AudioNode

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioNodeCreated:
        return cls(node=AudioNode.from_json(json['node']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioNodeCreated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioNodeWillBeDestroyed')
@dataclass
class AudioNodeWillBeDestroyed:
    """
    Notifies that an existing AudioNode has been destroyed.
    """

    context_id: GraphObjectId
    node_id: GraphObjectId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioNodeWillBeDestroyed:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            node_id=GraphObjectId.from_json(json['nodeId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioNodeWillBeDestroyed | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioParamCreated')
@dataclass
class AudioParamCreated:
    """
    Notifies that a new AudioParam has been created.
    """

    param: AudioParam

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioParamCreated:
        return cls(param=AudioParam.from_json(json['param']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioParamCreated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.audioParamWillBeDestroyed')
@dataclass
class AudioParamWillBeDestroyed:
    """
    Notifies that an existing AudioParam has been destroyed.
    """

    context_id: GraphObjectId
    node_id: GraphObjectId
    param_id: GraphObjectId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> AudioParamWillBeDestroyed:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            node_id=GraphObjectId.from_json(json['nodeId']),
            param_id=GraphObjectId.from_json(json['paramId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> AudioParamWillBeDestroyed | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.nodesConnected')
@dataclass
class NodesConnected:
    """
    Notifies that two AudioNodes are connected.
    """

    context_id: GraphObjectId
    source_id: GraphObjectId
    destination_id: GraphObjectId
    source_output_index: float | None
    destination_input_index: float | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NodesConnected:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            source_id=GraphObjectId.from_json(json['sourceId']),
            destination_id=GraphObjectId.from_json(json['destinationId']),
            source_output_index=None if json.get('sourceOutputIndex') is None else float(json['sourceOutputIndex']),
            destination_input_index=None
            if json.get('destinationInputIndex') is None
            else float(json['destinationInputIndex']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NodesConnected | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.nodesDisconnected')
@dataclass
class NodesDisconnected:
    """
    Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
    """

    context_id: GraphObjectId
    source_id: GraphObjectId
    destination_id: GraphObjectId
    source_output_index: float | None
    destination_input_index: float | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NodesDisconnected:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            source_id=GraphObjectId.from_json(json['sourceId']),
            destination_id=GraphObjectId.from_json(json['destinationId']),
            source_output_index=None if json.get('sourceOutputIndex') is None else float(json['sourceOutputIndex']),
            destination_input_index=None
            if json.get('destinationInputIndex') is None
            else float(json['destinationInputIndex']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NodesDisconnected | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.nodeParamConnected')
@dataclass
class NodeParamConnected:
    """
    Notifies that an AudioNode is connected to an AudioParam.
    """

    context_id: GraphObjectId
    source_id: GraphObjectId
    destination_id: GraphObjectId
    source_output_index: float | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NodeParamConnected:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            source_id=GraphObjectId.from_json(json['sourceId']),
            destination_id=GraphObjectId.from_json(json['destinationId']),
            source_output_index=None if json.get('sourceOutputIndex') is None else float(json['sourceOutputIndex']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NodeParamConnected | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('WebAudio.nodeParamDisconnected')
@dataclass
class NodeParamDisconnected:
    """
    Notifies that an AudioNode is disconnected to an AudioParam.
    """

    context_id: GraphObjectId
    source_id: GraphObjectId
    destination_id: GraphObjectId
    source_output_index: float | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NodeParamDisconnected:
        return cls(
            context_id=GraphObjectId.from_json(json['contextId']),
            source_id=GraphObjectId.from_json(json['sourceId']),
            destination_id=GraphObjectId.from_json(json['destinationId']),
            source_output_index=None if json.get('sourceOutputIndex') is None else float(json['sourceOutputIndex']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NodeParamDisconnected | None:
        if json is None:
            return None
        return cls.from_json(json)
