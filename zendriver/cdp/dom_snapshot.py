# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: DOMSnapshot (experimental)

from __future__ import annotations

import typing
from dataclasses import dataclass, field

from deprecated.sphinx import deprecated

from . import dom, dom_debugger, page


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


# ruff: noqa: FURB189


@dataclass
class DOMNode:
    """
    A Node in the DOM tree.
    """

    #: ``Node``'s nodeType.
    node_type: int

    #: ``Node``'s nodeName.
    node_name: str

    #: ``Node``'s nodeValue.
    node_value: str

    #: ``Node``'s id, corresponds to DOM.Node.backendNodeId.
    backend_node_id: dom.BackendNodeId

    #: Only set for textarea elements, contains the text value.
    text_value: str | None = None

    #: Only set for input elements, contains the input's associated text value.
    input_value: str | None = None

    #: Only set for radio and checkbox input elements, indicates if the element has been checked
    input_checked: bool | None = None

    #: Only set for option elements, indicates if the element has been selected
    option_selected: bool | None = None

    #: The indexes of the node's child nodes in the ``domNodes`` array returned by ``getSnapshot``, if
    #: any.
    child_node_indexes: list[int] = field(default_factory=list)

    #: Attributes of an ``Element`` node.
    attributes: list[NameValue] = field(default_factory=list)

    #: Indexes of pseudo elements associated with this node in the ``domNodes`` array returned by
    #: ``getSnapshot``, if any.
    pseudo_element_indexes: list[int] = field(default_factory=list)

    #: The index of the node's related layout tree node in the ``layoutTreeNodes`` array returned by
    #: ``getSnapshot``, if any.
    layout_node_index: int | None = None

    #: Document URL that ``Document`` or ``FrameOwner`` node points to.
    document_url: str | None = None

    #: Base URL that ``Document`` or ``FrameOwner`` node uses for URL completion.
    base_url: str | None = None

    #: Only set for documents, contains the document's content language.
    content_language: str | None = None

    #: Only set for documents, contains the document's character set encoding.
    document_encoding: str | None = None

    #: ``DocumentType`` node's publicId.
    public_id: str | None = None

    #: ``DocumentType`` node's systemId.
    system_id: str | None = None

    #: Frame ID for frame owner elements and also for the document node.
    frame_id: page.FrameId | None = None

    #: The index of a frame owner element's content document in the ``domNodes`` array returned by
    #: ``getSnapshot``, if any.
    content_document_index: int | None = None

    #: Type of a pseudo element node.
    pseudo_type: dom.PseudoType | None = None

    #: Shadow root type.
    shadow_root_type: dom.ShadowRootType | None = None

    #: Whether this DOM node responds to mouse clicks. This includes nodes that have had click
    #: event listeners attached via JavaScript as well as anchor tags that naturally navigate when
    #: clicked.
    is_clickable: bool | None = None

    #: Details of the node's event listeners, if any.
    event_listeners: list[dom_debugger.EventListener] = field(default_factory=list)

    #: The selected url for nodes with a srcset attribute.
    current_source_url: str | None = None

    #: The url of the script (if any) that generates this node.
    origin_url: str | None = None

    #: Scroll offsets, set when this node is a Document.
    scroll_offset_x: float | None = None

    scroll_offset_y: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['nodeType'] = self.node_type
        json['nodeName'] = self.node_name
        json['nodeValue'] = self.node_value
        json['backendNodeId'] = self.backend_node_id.to_json()
        if self.text_value is not None:
            json['textValue'] = self.text_value
        if self.input_value is not None:
            json['inputValue'] = self.input_value
        if self.input_checked is not None:
            json['inputChecked'] = self.input_checked
        if self.option_selected is not None:
            json['optionSelected'] = self.option_selected
        if self.child_node_indexes is not None:
            json['childNodeIndexes'] = self.child_node_indexes
        if self.attributes is not None:
            json['attributes'] = [i.to_json() for i in self.attributes]
        if self.pseudo_element_indexes is not None:
            json['pseudoElementIndexes'] = self.pseudo_element_indexes
        if self.layout_node_index is not None:
            json['layoutNodeIndex'] = self.layout_node_index
        if self.document_url is not None:
            json['documentURL'] = self.document_url
        if self.base_url is not None:
            json['baseURL'] = self.base_url
        if self.content_language is not None:
            json['contentLanguage'] = self.content_language
        if self.document_encoding is not None:
            json['documentEncoding'] = self.document_encoding
        if self.public_id is not None:
            json['publicId'] = self.public_id
        if self.system_id is not None:
            json['systemId'] = self.system_id
        if self.frame_id is not None:
            json['frameId'] = self.frame_id.to_json()
        if self.content_document_index is not None:
            json['contentDocumentIndex'] = self.content_document_index
        if self.pseudo_type is not None:
            json['pseudoType'] = self.pseudo_type.to_json()
        if self.shadow_root_type is not None:
            json['shadowRootType'] = self.shadow_root_type.to_json()
        if self.is_clickable is not None:
            json['isClickable'] = self.is_clickable
        if self.event_listeners is not None:
            json['eventListeners'] = [i.to_json() for i in self.event_listeners]
        if self.current_source_url is not None:
            json['currentSourceURL'] = self.current_source_url
        if self.origin_url is not None:
            json['originURL'] = self.origin_url
        if self.scroll_offset_x is not None:
            json['scrollOffsetX'] = self.scroll_offset_x
        if self.scroll_offset_y is not None:
            json['scrollOffsetY'] = self.scroll_offset_y
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DOMNode:
        return cls(
            node_type=int(json['nodeType']),
            node_name=str(json['nodeName']),
            node_value=str(json['nodeValue']),
            backend_node_id=dom.BackendNodeId.from_json(json['backendNodeId']),
            text_value=None if json.get('textValue') is None else str(json['textValue']),
            input_value=None if json.get('inputValue') is None else str(json['inputValue']),
            input_checked=None if json.get('inputChecked') is None else bool(json['inputChecked']),
            option_selected=None if json.get('optionSelected') is None else bool(json['optionSelected']),
            child_node_indexes=[int(i) for i in json.get('childNodeIndexes', [])],
            attributes=[NameValue.from_json(i) for i in json.get('attributes', [])],
            pseudo_element_indexes=[int(i) for i in json.get('pseudoElementIndexes', [])],
            layout_node_index=None if json.get('layoutNodeIndex') is None else int(json['layoutNodeIndex']),
            document_url=None if json.get('documentURL') is None else str(json['documentURL']),
            base_url=None if json.get('baseURL') is None else str(json['baseURL']),
            content_language=None if json.get('contentLanguage') is None else str(json['contentLanguage']),
            document_encoding=None if json.get('documentEncoding') is None else str(json['documentEncoding']),
            public_id=None if json.get('publicId') is None else str(json['publicId']),
            system_id=None if json.get('systemId') is None else str(json['systemId']),
            frame_id=page.FrameId.from_json_optional(json.get('frameId')),
            content_document_index=None
            if json.get('contentDocumentIndex') is None
            else int(json['contentDocumentIndex']),
            pseudo_type=dom.PseudoType.from_json_optional(json.get('pseudoType')),
            shadow_root_type=dom.ShadowRootType.from_json_optional(json.get('shadowRootType')),
            is_clickable=None if json.get('isClickable') is None else bool(json['isClickable']),
            event_listeners=[dom_debugger.EventListener.from_json(i) for i in json.get('eventListeners', [])],
            current_source_url=None if json.get('currentSourceURL') is None else str(json['currentSourceURL']),
            origin_url=None if json.get('originURL') is None else str(json['originURL']),
            scroll_offset_x=None if json.get('scrollOffsetX') is None else float(json['scrollOffsetX']),
            scroll_offset_y=None if json.get('scrollOffsetY') is None else float(json['scrollOffsetY']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DOMNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class InlineTextBox:
    """
    Details of post layout rendered text positions. The exact layout should not be regarded as
    stable and may change between versions.
    """

    #: The bounding box in document coordinates. Note that scroll offset of the document is ignored.
    bounding_box: dom.Rect

    #: The starting index in characters, for this post layout textbox substring. Characters that
    #: would be represented as a surrogate pair in UTF-16 have length 2.
    start_character_index: int

    #: The number of characters in this post layout textbox substring. Characters that would be
    #: represented as a surrogate pair in UTF-16 have length 2.
    num_characters: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['boundingBox'] = self.bounding_box.to_json()
        json['startCharacterIndex'] = self.start_character_index
        json['numCharacters'] = self.num_characters
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InlineTextBox:
        return cls(
            bounding_box=dom.Rect.from_json(json['boundingBox']),
            start_character_index=int(json['startCharacterIndex']),
            num_characters=int(json['numCharacters']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> InlineTextBox | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class LayoutTreeNode:
    """
    Details of an element in the DOM tree with a LayoutObject.
    """

    #: The index of the related DOM node in the ``domNodes`` array returned by ``getSnapshot``.
    dom_node_index: int

    #: The bounding box in document coordinates. Note that scroll offset of the document is ignored.
    bounding_box: dom.Rect

    #: Contents of the LayoutText, if any.
    layout_text: str | None = None

    #: The post-layout inline text nodes, if any.
    inline_text_nodes: list[InlineTextBox] = field(default_factory=list)

    #: Index into the ``computedStyles`` array returned by ``getSnapshot``.
    style_index: int | None = None

    #: Global paint order index, which is determined by the stacking order of the nodes. Nodes
    #: that are painted together will have the same index. Only provided if includePaintOrder in
    #: getSnapshot was true.
    paint_order: int | None = None

    #: Set to true to indicate the element begins a new stacking context.
    is_stacking_context: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['domNodeIndex'] = self.dom_node_index
        json['boundingBox'] = self.bounding_box.to_json()
        if self.layout_text is not None:
            json['layoutText'] = self.layout_text
        if self.inline_text_nodes is not None:
            json['inlineTextNodes'] = [i.to_json() for i in self.inline_text_nodes]
        if self.style_index is not None:
            json['styleIndex'] = self.style_index
        if self.paint_order is not None:
            json['paintOrder'] = self.paint_order
        if self.is_stacking_context is not None:
            json['isStackingContext'] = self.is_stacking_context
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LayoutTreeNode:
        return cls(
            dom_node_index=int(json['domNodeIndex']),
            bounding_box=dom.Rect.from_json(json['boundingBox']),
            layout_text=None if json.get('layoutText') is None else str(json['layoutText']),
            inline_text_nodes=[InlineTextBox.from_json(i) for i in json.get('inlineTextNodes', [])],
            style_index=None if json.get('styleIndex') is None else int(json['styleIndex']),
            paint_order=None if json.get('paintOrder') is None else int(json['paintOrder']),
            is_stacking_context=None if json.get('isStackingContext') is None else bool(json['isStackingContext']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> LayoutTreeNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ComputedStyle:
    """
    A subset of the full ComputedStyle as defined by the request whitelist.
    """

    #: Name/value pairs of computed style properties.
    properties: list[NameValue]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['properties'] = [i.to_json() for i in self.properties]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ComputedStyle:
        return cls(
            properties=[NameValue.from_json(i) for i in json.get('properties', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ComputedStyle | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class NameValue:
    """
    A name/value pair.
    """

    #: Attribute/property name.
    name: str

    #: Attribute/property value.
    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['value'] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NameValue:
        return cls(
            name=str(json['name']),
            value=str(json['value']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NameValue | None:
        if json is None:
            return None
        return cls.from_json(json)


class StringIndex(int):
    """
    Index of the string in the strings table.
    """

    def to_json(self) -> int:
        return self

    @classmethod
    def from_json(cls, json: int) -> StringIndex:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: int | None) -> StringIndex | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'StringIndex({super().__repr__()})'


class ArrayOfStrings(list):
    """
    Index of the string in the strings table.
    """

    def to_json(self) -> list[StringIndex]:
        return self

    @classmethod
    def from_json(cls, json: list[StringIndex]) -> ArrayOfStrings:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: list[StringIndex] | None) -> ArrayOfStrings | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'ArrayOfStrings({super().__repr__()})'


@dataclass
class RareStringData:
    """
    Data that is only present on rare nodes.
    """

    index: list[int]

    value: list[StringIndex]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['index'] = self.index
        json['value'] = [i.to_json() for i in self.value]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RareStringData:
        return cls(
            index=[int(i) for i in json.get('index', [])],
            value=[StringIndex.from_json(i) for i in json.get('value', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> RareStringData | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class RareBooleanData:
    index: list[int]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['index'] = self.index
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RareBooleanData:
        return cls(
            index=[int(i) for i in json.get('index', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> RareBooleanData | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class RareIntegerData:
    index: list[int]

    value: list[int]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['index'] = self.index
        json['value'] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RareIntegerData:
        return cls(
            index=[int(i) for i in json.get('index', [])],
            value=[int(i) for i in json.get('value', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> RareIntegerData | None:
        if json is None:
            return None
        return cls.from_json(json)


class Rectangle(list):
    def to_json(self) -> list[float]:
        return self

    @classmethod
    def from_json(cls, json: list[float]) -> Rectangle:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: list[float] | None) -> Rectangle | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'Rectangle({super().__repr__()})'


@dataclass
class DocumentSnapshot:
    """
    Document snapshot.
    """

    #: Document URL that ``Document`` or ``FrameOwner`` node points to.
    document_url: StringIndex

    #: Document title.
    title: StringIndex

    #: Base URL that ``Document`` or ``FrameOwner`` node uses for URL completion.
    base_url: StringIndex

    #: Contains the document's content language.
    content_language: StringIndex

    #: Contains the document's character set encoding.
    encoding_name: StringIndex

    #: ``DocumentType`` node's publicId.
    public_id: StringIndex

    #: ``DocumentType`` node's systemId.
    system_id: StringIndex

    #: Frame ID for frame owner elements and also for the document node.
    frame_id: StringIndex

    #: A table with dom nodes.
    nodes: NodeTreeSnapshot

    #: The nodes in the layout tree.
    layout: LayoutTreeSnapshot

    #: The post-layout inline text nodes.
    text_boxes: TextBoxSnapshot

    #: Horizontal scroll offset.
    scroll_offset_x: float | None = None

    #: Vertical scroll offset.
    scroll_offset_y: float | None = None

    #: Document content width.
    content_width: float | None = None

    #: Document content height.
    content_height: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['documentURL'] = self.document_url.to_json()
        json['title'] = self.title.to_json()
        json['baseURL'] = self.base_url.to_json()
        json['contentLanguage'] = self.content_language.to_json()
        json['encodingName'] = self.encoding_name.to_json()
        json['publicId'] = self.public_id.to_json()
        json['systemId'] = self.system_id.to_json()
        json['frameId'] = self.frame_id.to_json()
        json['nodes'] = self.nodes.to_json()
        json['layout'] = self.layout.to_json()
        json['textBoxes'] = self.text_boxes.to_json()
        if self.scroll_offset_x is not None:
            json['scrollOffsetX'] = self.scroll_offset_x
        if self.scroll_offset_y is not None:
            json['scrollOffsetY'] = self.scroll_offset_y
        if self.content_width is not None:
            json['contentWidth'] = self.content_width
        if self.content_height is not None:
            json['contentHeight'] = self.content_height
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DocumentSnapshot:
        return cls(
            document_url=StringIndex.from_json(json['documentURL']),
            title=StringIndex.from_json(json['title']),
            base_url=StringIndex.from_json(json['baseURL']),
            content_language=StringIndex.from_json(json['contentLanguage']),
            encoding_name=StringIndex.from_json(json['encodingName']),
            public_id=StringIndex.from_json(json['publicId']),
            system_id=StringIndex.from_json(json['systemId']),
            frame_id=StringIndex.from_json(json['frameId']),
            nodes=NodeTreeSnapshot.from_json(json['nodes']),
            layout=LayoutTreeSnapshot.from_json(json['layout']),
            text_boxes=TextBoxSnapshot.from_json(json['textBoxes']),
            scroll_offset_x=None if json.get('scrollOffsetX') is None else float(json['scrollOffsetX']),
            scroll_offset_y=None if json.get('scrollOffsetY') is None else float(json['scrollOffsetY']),
            content_width=None if json.get('contentWidth') is None else float(json['contentWidth']),
            content_height=None if json.get('contentHeight') is None else float(json['contentHeight']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DocumentSnapshot | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class NodeTreeSnapshot:
    """
    Table containing nodes.
    """

    #: Parent node index.
    parent_index: list[int] = field(default_factory=list)

    #: ``Node``'s nodeType.
    node_type: list[int] = field(default_factory=list)

    #: Type of the shadow root the ``Node`` is in. String values are equal to the ``ShadowRootType`` enum.
    shadow_root_type: RareStringData | None = None

    #: ``Node``'s nodeName.
    node_name: list[StringIndex] = field(default_factory=list)

    #: ``Node``'s nodeValue.
    node_value: list[StringIndex] = field(default_factory=list)

    #: ``Node``'s id, corresponds to DOM.Node.backendNodeId.
    backend_node_id: list[dom.BackendNodeId] = field(default_factory=list)

    #: Attributes of an ``Element`` node. Flatten name, value pairs.
    attributes: list[ArrayOfStrings] = field(default_factory=list)

    #: Only set for textarea elements, contains the text value.
    text_value: RareStringData | None = None

    #: Only set for input elements, contains the input's associated text value.
    input_value: RareStringData | None = None

    #: Only set for radio and checkbox input elements, indicates if the element has been checked
    input_checked: RareBooleanData | None = None

    #: Only set for option elements, indicates if the element has been selected
    option_selected: RareBooleanData | None = None

    #: The index of the document in the list of the snapshot documents.
    content_document_index: RareIntegerData | None = None

    #: Type of a pseudo element node.
    pseudo_type: RareStringData | None = None

    #: Pseudo element identifier for this node. Only present if there is a
    #: valid pseudoType.
    pseudo_identifier: RareStringData | None = None

    #: Whether this DOM node responds to mouse clicks. This includes nodes that have had click
    #: event listeners attached via JavaScript as well as anchor tags that naturally navigate when
    #: clicked.
    is_clickable: RareBooleanData | None = None

    #: The selected url for nodes with a srcset attribute.
    current_source_url: RareStringData | None = None

    #: The url of the script (if any) that generates this node.
    origin_url: RareStringData | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.parent_index is not None:
            json['parentIndex'] = self.parent_index
        if self.node_type is not None:
            json['nodeType'] = self.node_type
        if self.shadow_root_type is not None:
            json['shadowRootType'] = self.shadow_root_type.to_json()
        if self.node_name is not None:
            json['nodeName'] = [i.to_json() for i in self.node_name]
        if self.node_value is not None:
            json['nodeValue'] = [i.to_json() for i in self.node_value]
        if self.backend_node_id is not None:
            json['backendNodeId'] = [i.to_json() for i in self.backend_node_id]
        if self.attributes is not None:
            json['attributes'] = [i.to_json() for i in self.attributes]
        if self.text_value is not None:
            json['textValue'] = self.text_value.to_json()
        if self.input_value is not None:
            json['inputValue'] = self.input_value.to_json()
        if self.input_checked is not None:
            json['inputChecked'] = self.input_checked.to_json()
        if self.option_selected is not None:
            json['optionSelected'] = self.option_selected.to_json()
        if self.content_document_index is not None:
            json['contentDocumentIndex'] = self.content_document_index.to_json()
        if self.pseudo_type is not None:
            json['pseudoType'] = self.pseudo_type.to_json()
        if self.pseudo_identifier is not None:
            json['pseudoIdentifier'] = self.pseudo_identifier.to_json()
        if self.is_clickable is not None:
            json['isClickable'] = self.is_clickable.to_json()
        if self.current_source_url is not None:
            json['currentSourceURL'] = self.current_source_url.to_json()
        if self.origin_url is not None:
            json['originURL'] = self.origin_url.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> NodeTreeSnapshot:
        return cls(
            parent_index=[int(i) for i in json.get('parentIndex', [])],
            node_type=[int(i) for i in json.get('nodeType', [])],
            shadow_root_type=RareStringData.from_json_optional(json.get('shadowRootType')),
            node_name=[StringIndex.from_json(i) for i in json.get('nodeName', [])],
            node_value=[StringIndex.from_json(i) for i in json.get('nodeValue', [])],
            backend_node_id=[dom.BackendNodeId.from_json(i) for i in json.get('backendNodeId', [])],
            attributes=[ArrayOfStrings.from_json(i) for i in json.get('attributes', [])],
            text_value=RareStringData.from_json_optional(json.get('textValue')),
            input_value=RareStringData.from_json_optional(json.get('inputValue')),
            input_checked=RareBooleanData.from_json_optional(json.get('inputChecked')),
            option_selected=RareBooleanData.from_json_optional(json.get('optionSelected')),
            content_document_index=RareIntegerData.from_json_optional(json.get('contentDocumentIndex')),
            pseudo_type=RareStringData.from_json_optional(json.get('pseudoType')),
            pseudo_identifier=RareStringData.from_json_optional(json.get('pseudoIdentifier')),
            is_clickable=RareBooleanData.from_json_optional(json.get('isClickable')),
            current_source_url=RareStringData.from_json_optional(json.get('currentSourceURL')),
            origin_url=RareStringData.from_json_optional(json.get('originURL')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> NodeTreeSnapshot | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class LayoutTreeSnapshot:
    """
    Table of details of an element in the DOM tree with a LayoutObject.
    """

    #: Index of the corresponding node in the ``NodeTreeSnapshot`` array returned by ``captureSnapshot``.
    node_index: list[int]

    #: Array of indexes specifying computed style strings, filtered according to the ``computedStyles`` parameter passed to ``captureSnapshot``.
    styles: list[ArrayOfStrings]

    #: The absolute position bounding box.
    bounds: list[Rectangle]

    #: Contents of the LayoutText, if any.
    text: list[StringIndex]

    #: Stacking context information.
    stacking_contexts: RareBooleanData

    #: Global paint order index, which is determined by the stacking order of the nodes. Nodes
    #: that are painted together will have the same index. Only provided if includePaintOrder in
    #: captureSnapshot was true.
    paint_orders: list[int] = field(default_factory=list)

    #: The offset rect of nodes. Only available when includeDOMRects is set to true
    offset_rects: list[Rectangle] = field(default_factory=list)

    #: The scroll rect of nodes. Only available when includeDOMRects is set to true
    scroll_rects: list[Rectangle] = field(default_factory=list)

    #: The client rect of nodes. Only available when includeDOMRects is set to true
    client_rects: list[Rectangle] = field(default_factory=list)

    #: The list of background colors that are blended with colors of overlapping elements.
    blended_background_colors: list[StringIndex] = field(default_factory=list)

    #: The list of computed text opacities.
    text_color_opacities: list[float] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['nodeIndex'] = self.node_index
        json['styles'] = [i.to_json() for i in self.styles]
        json['bounds'] = [i.to_json() for i in self.bounds]
        json['text'] = [i.to_json() for i in self.text]
        json['stackingContexts'] = self.stacking_contexts.to_json()
        if self.paint_orders is not None:
            json['paintOrders'] = self.paint_orders
        if self.offset_rects is not None:
            json['offsetRects'] = [i.to_json() for i in self.offset_rects]
        if self.scroll_rects is not None:
            json['scrollRects'] = [i.to_json() for i in self.scroll_rects]
        if self.client_rects is not None:
            json['clientRects'] = [i.to_json() for i in self.client_rects]
        if self.blended_background_colors is not None:
            json['blendedBackgroundColors'] = [i.to_json() for i in self.blended_background_colors]
        if self.text_color_opacities is not None:
            json['textColorOpacities'] = self.text_color_opacities
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LayoutTreeSnapshot:
        return cls(
            node_index=[int(i) for i in json.get('nodeIndex', [])],
            styles=[ArrayOfStrings.from_json(i) for i in json.get('styles', [])],
            bounds=[Rectangle.from_json(i) for i in json.get('bounds', [])],
            text=[StringIndex.from_json(i) for i in json.get('text', [])],
            stacking_contexts=RareBooleanData.from_json(json['stackingContexts']),
            paint_orders=[int(i) for i in json.get('paintOrders', [])],
            offset_rects=[Rectangle.from_json(i) for i in json.get('offsetRects', [])],
            scroll_rects=[Rectangle.from_json(i) for i in json.get('scrollRects', [])],
            client_rects=[Rectangle.from_json(i) for i in json.get('clientRects', [])],
            blended_background_colors=[StringIndex.from_json(i) for i in json.get('blendedBackgroundColors', [])],
            text_color_opacities=[float(i) for i in json.get('textColorOpacities', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> LayoutTreeSnapshot | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class TextBoxSnapshot:
    """
    Table of details of the post layout rendered text positions. The exact layout should not be regarded as
    stable and may change between versions.
    """

    #: Index of the layout tree node that owns this box collection.
    layout_index: list[int]

    #: The absolute position bounding box.
    bounds: list[Rectangle]

    #: The starting index in characters, for this post layout textbox substring. Characters that
    #: would be represented as a surrogate pair in UTF-16 have length 2.
    start: list[int]

    #: The number of characters in this post layout textbox substring. Characters that would be
    #: represented as a surrogate pair in UTF-16 have length 2.
    length: list[int]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['layoutIndex'] = self.layout_index
        json['bounds'] = [i.to_json() for i in self.bounds]
        json['start'] = self.start
        json['length'] = self.length
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TextBoxSnapshot:
        return cls(
            layout_index=[int(i) for i in json.get('layoutIndex', [])],
            bounds=[Rectangle.from_json(i) for i in json.get('bounds', [])],
            start=[int(i) for i in json.get('start', [])],
            length=[int(i) for i in json.get('length', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> TextBoxSnapshot | None:
        if json is None:
            return None
        return cls.from_json(json)


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables DOM snapshot agent for the given page.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'DOMSnapshot.disable',
    }
    json = yield cmd_dict


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables DOM snapshot agent for the given page.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'DOMSnapshot.enable',
    }
    json = yield cmd_dict


@deprecated(version='1.3')
def get_snapshot(
    computed_style_whitelist: list[str],
    *,
    include_event_listeners: bool | None = None,
    include_paint_order: bool | None = None,
    include_user_agent_shadow_tree: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DOMNode], list[LayoutTreeNode], list[ComputedStyle]]]:
    """
    Returns a document snapshot, including the full DOM tree of the root node (including iframes,
    template contents, and imported documents) in a flattened array, as well as layout and
    white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
    flattened.

    .. deprecated:: 1.3

    :param computed_style_whitelist: Whitelist of computed styles to return.
    :param include_event_listeners: *(Optional)* Whether or not to retrieve details of DOM listeners (default false).
    :param include_paint_order: *(Optional)* Whether to determine and include the paint order index of LayoutTreeNodes (default false).
    :param include_user_agent_shadow_tree: *(Optional)* Whether to include UA shadow tree in the snapshot (default false).
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DOMNode], list[LayoutTreeNode], list[ComputedStyle]]]
    """

    params: T_JSON_DICT = {}
    params['computedStyleWhitelist'] = computed_style_whitelist
    if include_event_listeners is not None:
        params['includeEventListeners'] = include_event_listeners
    if include_paint_order is not None:
        params['includePaintOrder'] = include_paint_order
    if include_user_agent_shadow_tree is not None:
        params['includeUserAgentShadowTree'] = include_user_agent_shadow_tree
    cmd_dict: T_JSON_DICT = {
        'method': 'DOMSnapshot.getSnapshot',
        'params': params,
    }
    json = yield cmd_dict
    return (
        [DOMNode.from_json(i) for i in json.get('domNodes', [])],
        [LayoutTreeNode.from_json(i) for i in json.get('layoutTreeNodes', [])],
        [ComputedStyle.from_json(i) for i in json.get('computedStyles', [])],
    )


def capture_snapshot(
    computed_styles: list[str],
    *,
    include_paint_order: bool | None = None,
    include_dom_rects: bool | None = None,
    include_blended_background_colors: bool | None = None,
    include_text_color_opacities: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DocumentSnapshot], list[str]]]:
    """
    Returns a document snapshot, including the full DOM tree of the root node (including iframes,
    template contents, and imported documents) in a flattened array, as well as layout and
    white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
    flattened.

    :param computed_styles: Whitelist of computed styles to return.
    :param include_paint_order: *(Optional)* Whether to include layout object paint orders into the snapshot.
    :param include_dom_rects: *(Optional)* Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
    :param include_blended_background_colors: **(EXPERIMENTAL)** *(Optional)* Whether to include blended background colors in the snapshot (default: false). Blended background color is achieved by blending background colors of all elements that overlap with the current element.
    :param include_text_color_opacities: **(EXPERIMENTAL)** *(Optional)* Whether to include text color opacity in the snapshot (default: false). An element might have the opacity property set that affects the text color of the element. The final text color opacity is computed based on the opacity of all overlapping elements.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[DocumentSnapshot], list[str]]]
    """

    params: T_JSON_DICT = {}
    params['computedStyles'] = computed_styles
    if include_paint_order is not None:
        params['includePaintOrder'] = include_paint_order
    if include_dom_rects is not None:
        params['includeDOMRects'] = include_dom_rects
    if include_blended_background_colors is not None:
        params['includeBlendedBackgroundColors'] = include_blended_background_colors
    if include_text_color_opacities is not None:
        params['includeTextColorOpacities'] = include_text_color_opacities
    cmd_dict: T_JSON_DICT = {
        'method': 'DOMSnapshot.captureSnapshot',
        'params': params,
    }
    json = yield cmd_dict
    return (
        [DocumentSnapshot.from_json(i) for i in json.get('documents', [])],
        [str(i) for i in json.get('strings', [])],
    )
