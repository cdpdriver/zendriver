# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: Memory (experimental)

from __future__ import annotations

import enum
import typing
from dataclasses import dataclass


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


class PressureLevel(enum.Enum):
    """
    Memory pressure level.
    """

    MODERATE = 'moderate'
    CRITICAL = 'critical'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> PressureLevel:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> PressureLevel | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class SamplingProfileNode:
    """
    Heap profile sample.
    """

    #: Size of the sampled allocation.
    size: float

    #: Total bytes attributed to this sample.
    total: float

    #: Execution stack at the point of allocation.
    stack: list[str]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['size'] = self.size
        json['total'] = self.total
        json['stack'] = self.stack
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SamplingProfileNode:
        return cls(
            size=float(json['size']),
            total=float(json['total']),
            stack=[str(i) for i in json.get('stack', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> SamplingProfileNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class SamplingProfile:
    """
    Array of heap profile samples.
    """

    samples: list[SamplingProfileNode]

    modules: list[Module]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['samples'] = [i.to_json() for i in self.samples]
        json['modules'] = [i.to_json() for i in self.modules]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SamplingProfile:
        return cls(
            samples=[SamplingProfileNode.from_json(i) for i in json.get('samples', [])],
            modules=[Module.from_json(i) for i in json.get('modules', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> SamplingProfile | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Module:
    """
    Executable module information
    """

    #: Name of the module.
    name: str

    #: UUID of the module.
    uuid: str

    #: Base address where the module is loaded into memory. Encoded as a decimal
    #: or hexadecimal (0x prefixed) string.
    base_address: str

    #: Size of the module in bytes.
    size: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['uuid'] = self.uuid
        json['baseAddress'] = self.base_address
        json['size'] = self.size
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Module:
        return cls(
            name=str(json['name']),
            uuid=str(json['uuid']),
            base_address=str(json['baseAddress']),
            size=float(json['size']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Module | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class DOMCounter:
    """
    DOM object counter data.
    """

    #: Object name. Note: object names should be presumed volatile and clients should not expect
    #: the returned names to be consistent across runs.
    name: str

    #: Object count.
    count: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['count'] = self.count
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DOMCounter:
        return cls(
            name=str(json['name']),
            count=int(json['count']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> DOMCounter | None:
        if json is None:
            return None
        return cls.from_json(json)


def get_dom_counters() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, int, int]]:
    """
    Retruns current DOM object counters.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[int, int, int]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.getDOMCounters',
    }
    json = yield cmd_dict
    return (int(json['documents']), int(json['nodes']), int(json['jsEventListeners']))


def get_dom_counters_for_leak_detection() -> Generator[T_JSON_DICT, T_JSON_DICT, list[DOMCounter]]:
    """
    Retruns DOM object counters after preparing renderer for leak detection.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[DOMCounter]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.getDOMCountersForLeakDetection',
    }
    json = yield cmd_dict
    return [DOMCounter.from_json(i) for i in json.get('counters', [])]


def prepare_for_leak_detection() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Prepares for leak detection by terminating workers, stopping spellcheckers,
    dropping non-essential internal caches, running garbage collections, etc.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.prepareForLeakDetection',
    }
    json = yield cmd_dict


def forcibly_purge_java_script_memory() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulate OomIntervention by purging V8 memory.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.forciblyPurgeJavaScriptMemory',
    }
    json = yield cmd_dict


def set_pressure_notifications_suppressed(
    *,
    suppressed: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enable/disable suppressing memory pressure notifications in all processes.

    :param suppressed: If true, memory pressure notifications will be suppressed.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['suppressed'] = suppressed
    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.setPressureNotificationsSuppressed',
        'params': params,
    }
    json = yield cmd_dict


def simulate_pressure_notification(
    level: PressureLevel,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Simulate a memory pressure notification in all processes.

    :param level: Memory pressure level of the notification.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['level'] = level.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.simulatePressureNotification',
        'params': params,
    }
    json = yield cmd_dict


def start_sampling(
    *,
    sampling_interval: int | None = None,
    suppress_randomness: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Start collecting native memory profile.

    :param sampling_interval: *(Optional)* Average number of bytes between samples.
    :param suppress_randomness: *(Optional)* Do not randomize intervals between samples.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    if sampling_interval is not None:
        params['samplingInterval'] = sampling_interval
    if suppress_randomness is not None:
        params['suppressRandomness'] = suppress_randomness
    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.startSampling',
        'params': params,
    }
    json = yield cmd_dict


def stop_sampling() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Stop collecting native memory profile.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.stopSampling',
    }
    json = yield cmd_dict


def get_all_time_sampling_profile() -> Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]:
    """
    Retrieve native memory allocations profile
    collected since renderer process startup.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.getAllTimeSamplingProfile',
    }
    json = yield cmd_dict
    return SamplingProfile.from_json(json['profile'])


def get_browser_sampling_profile() -> Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]:
    """
    Retrieve native memory allocations profile
    collected since browser process startup.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.getBrowserSamplingProfile',
    }
    json = yield cmd_dict
    return SamplingProfile.from_json(json['profile'])


def get_sampling_profile() -> Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]:
    """
    Retrieve native memory allocations profile collected since last
    ``startSampling`` call.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, SamplingProfile]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Memory.getSamplingProfile',
    }
    json = yield cmd_dict
    return SamplingProfile.from_json(json['profile'])
