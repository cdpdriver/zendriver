# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: CSS (experimental)

from __future__ import annotations

import enum
import typing
from dataclasses import dataclass, field

from . import dom, page
from .util import event_type


if typing.TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


# ruff: noqa: FURB189


class StyleSheetId(str):
    __slots__ = ()

    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> StyleSheetId:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> StyleSheetId | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'StyleSheetId({super().__repr__()})'


class StyleSheetOrigin(enum.Enum):
    """
    Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
    stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
    inspector" rules), "regular" for regular stylesheets.
    """

    INJECTED = 'injected'
    USER_AGENT = 'user-agent'
    INSPECTOR = 'inspector'
    REGULAR = 'regular'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> StyleSheetOrigin:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> StyleSheetOrigin | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PseudoElementMatches:
    """
    CSS rule collection for a single pseudo style.
    """

    #: Pseudo element type.
    pseudo_type: dom.PseudoType

    #: Matches of CSS rules applicable to the pseudo style.
    matches: list[RuleMatch]

    #: Pseudo element custom ident.
    pseudo_identifier: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['pseudoType'] = self.pseudo_type.to_json()
        json['matches'] = [i.to_json() for i in self.matches]
        if self.pseudo_identifier is not None:
            json['pseudoIdentifier'] = self.pseudo_identifier
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PseudoElementMatches:
        return cls(
            pseudo_type=dom.PseudoType.from_json(json['pseudoType']),
            matches=[RuleMatch.from_json(i) for i in json.get('matches', [])],
            pseudo_identifier=None if json.get('pseudoIdentifier') is None else str(json['pseudoIdentifier']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PseudoElementMatches | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSAnimationStyle:
    """
    CSS style coming from animations with the name of the animation.
    """

    #: The style coming from the animation.
    style: CSSStyle

    #: The name of the animation.
    name: str | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['style'] = self.style.to_json()
        if self.name is not None:
            json['name'] = self.name
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSAnimationStyle:
        return cls(
            style=CSSStyle.from_json(json['style']),
            name=None if json.get('name') is None else str(json['name']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSAnimationStyle | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class InheritedStyleEntry:
    """
    Inherited CSS rule collection from ancestor node.
    """

    #: Matches of CSS rules matching the ancestor node in the style inheritance chain.
    matched_css_rules: list[RuleMatch]

    #: The ancestor node's inline style, if any, in the style inheritance chain.
    inline_style: CSSStyle | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['matchedCSSRules'] = [i.to_json() for i in self.matched_css_rules]
        if self.inline_style is not None:
            json['inlineStyle'] = self.inline_style.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InheritedStyleEntry:
        return cls(
            matched_css_rules=[RuleMatch.from_json(i) for i in json.get('matchedCSSRules', [])],
            inline_style=CSSStyle.from_json_optional(json.get('inlineStyle')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> InheritedStyleEntry | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class InheritedAnimatedStyleEntry:
    """
    Inherited CSS style collection for animated styles from ancestor node.
    """

    #: Styles coming from the animations of the ancestor, if any, in the style inheritance chain.
    animation_styles: list[CSSAnimationStyle] = field(default_factory=list)

    #: The style coming from the transitions of the ancestor, if any, in the style inheritance chain.
    transitions_style: CSSStyle | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.animation_styles is not None:
            json['animationStyles'] = [i.to_json() for i in self.animation_styles]
        if self.transitions_style is not None:
            json['transitionsStyle'] = self.transitions_style.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InheritedAnimatedStyleEntry:
        return cls(
            animation_styles=[CSSAnimationStyle.from_json(i) for i in json.get('animationStyles', [])],
            transitions_style=CSSStyle.from_json_optional(json.get('transitionsStyle')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> InheritedAnimatedStyleEntry | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class InheritedPseudoElementMatches:
    """
    Inherited pseudo element matches from pseudos of an ancestor node.
    """

    #: Matches of pseudo styles from the pseudos of an ancestor node.
    pseudo_elements: list[PseudoElementMatches]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['pseudoElements'] = [i.to_json() for i in self.pseudo_elements]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> InheritedPseudoElementMatches:
        return cls(
            pseudo_elements=[PseudoElementMatches.from_json(i) for i in json.get('pseudoElements', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> InheritedPseudoElementMatches | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class RuleMatch:
    """
    Match data for a CSS rule.
    """

    #: CSS rule in the match.
    rule: CSSRule

    #: Matching selector indices in the rule's selectorList selectors (0-based).
    matching_selectors: list[int]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['rule'] = self.rule.to_json()
        json['matchingSelectors'] = self.matching_selectors
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RuleMatch:
        return cls(
            rule=CSSRule.from_json(json['rule']),
            matching_selectors=[int(i) for i in json.get('matchingSelectors', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> RuleMatch | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Value:
    """
    Data for a simple selector (these are delimited by commas in a selector list).
    """

    #: Value text.
    text: str

    #: Value range in the underlying resource (if available).
    range_: SourceRange | None = None

    #: Specificity of the selector.
    specificity: Specificity | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.specificity is not None:
            json['specificity'] = self.specificity.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Value:
        return cls(
            text=str(json['text']),
            range_=SourceRange.from_json_optional(json.get('range')),
            specificity=Specificity.from_json_optional(json.get('specificity')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Value | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Specificity:
    """
    Specificity:
    https://drafts.csswg.org/selectors/#specificity-rules
    """

    #: The a component, which represents the number of ID selectors.
    a: int

    #: The b component, which represents the number of class selectors, attributes selectors, and
    #: pseudo-classes.
    b: int

    #: The c component, which represents the number of type selectors and pseudo-elements.
    c: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['a'] = self.a
        json['b'] = self.b
        json['c'] = self.c
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Specificity:
        return cls(
            a=int(json['a']),
            b=int(json['b']),
            c=int(json['c']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Specificity | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class SelectorList:
    """
    Selector list data.
    """

    #: Selectors in the list.
    selectors: list[Value]

    #: Rule selector text.
    text: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['selectors'] = [i.to_json() for i in self.selectors]
        json['text'] = self.text
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SelectorList:
        return cls(
            selectors=[Value.from_json(i) for i in json.get('selectors', [])],
            text=str(json['text']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> SelectorList | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSStyleSheetHeader:
    """
    CSS stylesheet metainformation.
    """

    #: The stylesheet identifier.
    style_sheet_id: StyleSheetId

    #: Owner frame identifier.
    frame_id: page.FrameId

    #: Stylesheet resource URL. Empty if this is a constructed stylesheet created using
    #: new CSSStyleSheet() (but non-empty if this is a constructed stylesheet imported
    #: as a CSS module script).
    source_url: str

    #: Stylesheet origin.
    origin: StyleSheetOrigin

    #: Stylesheet title.
    title: str

    #: Denotes whether the stylesheet is disabled.
    disabled: bool

    #: Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
    #: document.written STYLE tags.
    is_inline: bool

    #: Whether this stylesheet is mutable. Inline stylesheets become mutable
    #: after they have been modified via CSSOM API.
    #: ``<link>`` element's stylesheets become mutable only if DevTools modifies them.
    #: Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
    is_mutable: bool

    #: True if this stylesheet is created through new CSSStyleSheet() or imported as a
    #: CSS module script.
    is_constructed: bool

    #: Line offset of the stylesheet within the resource (zero based).
    start_line: float

    #: Column offset of the stylesheet within the resource (zero based).
    start_column: float

    #: Size of the content (in characters).
    length: float

    #: Line offset of the end of the stylesheet within the resource (zero based).
    end_line: float

    #: Column offset of the end of the stylesheet within the resource (zero based).
    end_column: float

    #: URL of source map associated with the stylesheet (if any).
    source_map_url: str | None = None

    #: The backend id for the owner node of the stylesheet.
    owner_node: dom.BackendNodeId | None = None

    #: Whether the sourceURL field value comes from the sourceURL comment.
    has_source_url: bool | None = None

    #: If the style sheet was loaded from a network resource, this indicates when the resource failed to load
    loading_failed: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['styleSheetId'] = self.style_sheet_id.to_json()
        json['frameId'] = self.frame_id.to_json()
        json['sourceURL'] = self.source_url
        json['origin'] = self.origin.to_json()
        json['title'] = self.title
        json['disabled'] = self.disabled
        json['isInline'] = self.is_inline
        json['isMutable'] = self.is_mutable
        json['isConstructed'] = self.is_constructed
        json['startLine'] = self.start_line
        json['startColumn'] = self.start_column
        json['length'] = self.length
        json['endLine'] = self.end_line
        json['endColumn'] = self.end_column
        if self.source_map_url is not None:
            json['sourceMapURL'] = self.source_map_url
        if self.owner_node is not None:
            json['ownerNode'] = self.owner_node.to_json()
        if self.has_source_url is not None:
            json['hasSourceURL'] = self.has_source_url
        if self.loading_failed is not None:
            json['loadingFailed'] = self.loading_failed
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSStyleSheetHeader:
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            frame_id=page.FrameId.from_json(json['frameId']),
            source_url=str(json['sourceURL']),
            origin=StyleSheetOrigin.from_json(json['origin']),
            title=str(json['title']),
            disabled=bool(json['disabled']),
            is_inline=bool(json['isInline']),
            is_mutable=bool(json['isMutable']),
            is_constructed=bool(json['isConstructed']),
            start_line=float(json['startLine']),
            start_column=float(json['startColumn']),
            length=float(json['length']),
            end_line=float(json['endLine']),
            end_column=float(json['endColumn']),
            source_map_url=None if json.get('sourceMapURL') is None else str(json['sourceMapURL']),
            owner_node=dom.BackendNodeId.from_json_optional(json.get('ownerNode')),
            has_source_url=None if json.get('hasSourceURL') is None else bool(json['hasSourceURL']),
            loading_failed=None if json.get('loadingFailed') is None else bool(json['loadingFailed']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSStyleSheetHeader | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSRule:
    """
    CSS rule representation.
    """

    #: Rule selector data.
    selector_list: SelectorList

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    #: Array of selectors from ancestor style rules, sorted by distance from the current rule.
    nesting_selectors: list[str] = field(default_factory=list)

    #: The BackendNodeId of the DOM node that constitutes the origin tree scope of this rule.
    origin_tree_scope_node_id: dom.BackendNodeId | None = None

    #: Media list array (for rules involving media queries). The array enumerates media queries
    #: starting with the innermost one, going outwards.
    media: list[CSSMedia] = field(default_factory=list)

    #: Container query list array (for rules involving container queries).
    #: The array enumerates container queries starting with the innermost one, going outwards.
    container_queries: list[CSSContainerQuery] = field(default_factory=list)

    #: @supports CSS at-rule array.
    #: The array enumerates @supports at-rules starting with the innermost one, going outwards.
    supports: list[CSSSupports] = field(default_factory=list)

    #: Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
    #: with the innermost layer and going outwards.
    layers: list[CSSLayer] = field(default_factory=list)

    #: @scope CSS at-rule array.
    #: The array enumerates @scope at-rules starting with the innermost one, going outwards.
    scopes: list[CSSScope] = field(default_factory=list)

    #: The array keeps the types of ancestor CSSRules from the innermost going outwards.
    rule_types: list[CSSRuleType] = field(default_factory=list)

    #: @starting-style CSS at-rule array.
    #: The array enumerates @starting-style at-rules starting with the innermost one, going outwards.
    starting_styles: list[CSSStartingStyle] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['selectorList'] = self.selector_list.to_json()
        json['origin'] = self.origin.to_json()
        json['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.nesting_selectors is not None:
            json['nestingSelectors'] = self.nesting_selectors
        if self.origin_tree_scope_node_id is not None:
            json['originTreeScopeNodeId'] = self.origin_tree_scope_node_id.to_json()
        if self.media is not None:
            json['media'] = [i.to_json() for i in self.media]
        if self.container_queries is not None:
            json['containerQueries'] = [i.to_json() for i in self.container_queries]
        if self.supports is not None:
            json['supports'] = [i.to_json() for i in self.supports]
        if self.layers is not None:
            json['layers'] = [i.to_json() for i in self.layers]
        if self.scopes is not None:
            json['scopes'] = [i.to_json() for i in self.scopes]
        if self.rule_types is not None:
            json['ruleTypes'] = [i.to_json() for i in self.rule_types]
        if self.starting_styles is not None:
            json['startingStyles'] = [i.to_json() for i in self.starting_styles]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSRule:
        return cls(
            selector_list=SelectorList.from_json(json['selectorList']),
            origin=StyleSheetOrigin.from_json(json['origin']),
            style=CSSStyle.from_json(json['style']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
            nesting_selectors=[str(i) for i in json.get('nestingSelectors', [])],
            origin_tree_scope_node_id=dom.BackendNodeId.from_json_optional(json.get('originTreeScopeNodeId')),
            media=[CSSMedia.from_json(i) for i in json.get('media', [])],
            container_queries=[CSSContainerQuery.from_json(i) for i in json.get('containerQueries', [])],
            supports=[CSSSupports.from_json(i) for i in json.get('supports', [])],
            layers=[CSSLayer.from_json(i) for i in json.get('layers', [])],
            scopes=[CSSScope.from_json(i) for i in json.get('scopes', [])],
            rule_types=[CSSRuleType.from_json(i) for i in json.get('ruleTypes', [])],
            starting_styles=[CSSStartingStyle.from_json(i) for i in json.get('startingStyles', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSRule | None:
        if json is None:
            return None
        return cls.from_json(json)


class CSSRuleType(enum.Enum):
    """
    Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
    This list only contains rule types that are collected during the ancestor rule collection.
    """

    MEDIA_RULE = 'MediaRule'
    SUPPORTS_RULE = 'SupportsRule'
    CONTAINER_RULE = 'ContainerRule'
    LAYER_RULE = 'LayerRule'
    SCOPE_RULE = 'ScopeRule'
    STYLE_RULE = 'StyleRule'
    STARTING_STYLE_RULE = 'StartingStyleRule'

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> CSSRuleType:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> CSSRuleType | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class RuleUsage:
    """
    CSS coverage information.
    """

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: Offset of the start of the rule (including selector) from the beginning of the stylesheet.
    start_offset: float

    #: Offset of the end of the rule body from the beginning of the stylesheet.
    end_offset: float

    #: Indicates whether the rule was actually used by some element in the page.
    used: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['styleSheetId'] = self.style_sheet_id.to_json()
        json['startOffset'] = self.start_offset
        json['endOffset'] = self.end_offset
        json['used'] = self.used
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> RuleUsage:
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            start_offset=float(json['startOffset']),
            end_offset=float(json['endOffset']),
            used=bool(json['used']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> RuleUsage | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class SourceRange:
    """
    Text range within a resource. All numbers are zero-based.
    """

    #: Start line of range.
    start_line: int

    #: Start column of range (inclusive).
    start_column: int

    #: End line of range
    end_line: int

    #: End column of range (exclusive).
    end_column: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['startLine'] = self.start_line
        json['startColumn'] = self.start_column
        json['endLine'] = self.end_line
        json['endColumn'] = self.end_column
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SourceRange:
        return cls(
            start_line=int(json['startLine']),
            start_column=int(json['startColumn']),
            end_line=int(json['endLine']),
            end_column=int(json['endColumn']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> SourceRange | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ShorthandEntry:
    #: Shorthand name.
    name: str

    #: Shorthand value.
    value: str

    #: Whether the property has "!important" annotation (implies ``false`` if absent).
    important: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['value'] = self.value
        if self.important is not None:
            json['important'] = self.important
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ShorthandEntry:
        return cls(
            name=str(json['name']),
            value=str(json['value']),
            important=None if json.get('important') is None else bool(json['important']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ShorthandEntry | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSComputedStyleProperty:
    #: Computed style property name.
    name: str

    #: Computed style property value.
    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['value'] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSComputedStyleProperty:
        return cls(
            name=str(json['name']),
            value=str(json['value']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSComputedStyleProperty | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class ComputedStyleExtraFields:
    #: Returns whether or not this node is being rendered with base appearance,
    #: which happens when it has its appearance property set to base/base-select
    #: or it is in the subtree of an element being rendered with base appearance.
    is_appearance_base: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['isAppearanceBase'] = self.is_appearance_base
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ComputedStyleExtraFields:
        return cls(
            is_appearance_base=bool(json['isAppearanceBase']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ComputedStyleExtraFields | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSStyle:
    """
    CSS style representation.
    """

    #: CSS properties in the style.
    css_properties: list[CSSProperty]

    #: Computed values for all shorthands found in the style.
    shorthand_entries: list[ShorthandEntry]

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    #: Style declaration text (if available).
    css_text: str | None = None

    #: Style declaration range in the enclosing stylesheet (if available).
    range_: SourceRange | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['cssProperties'] = [i.to_json() for i in self.css_properties]
        json['shorthandEntries'] = [i.to_json() for i in self.shorthand_entries]
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.css_text is not None:
            json['cssText'] = self.css_text
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSStyle:
        return cls(
            css_properties=[CSSProperty.from_json(i) for i in json.get('cssProperties', [])],
            shorthand_entries=[ShorthandEntry.from_json(i) for i in json.get('shorthandEntries', [])],
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
            css_text=None if json.get('cssText') is None else str(json['cssText']),
            range_=SourceRange.from_json_optional(json.get('range')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSStyle | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSProperty:
    """
    CSS property declaration data.
    """

    #: The property name.
    name: str

    #: The property value.
    value: str

    #: Whether the property has "!important" annotation (implies ``false`` if absent).
    important: bool | None = None

    #: Whether the property is implicit (implies ``false`` if absent).
    implicit: bool | None = None

    #: The full property text as specified in the style.
    text: str | None = None

    #: Whether the property is understood by the browser (implies ``true`` if absent).
    parsed_ok: bool | None = None

    #: Whether the property is disabled by the user (present for source-based properties only).
    disabled: bool | None = None

    #: The entire property range in the enclosing style declaration (if available).
    range_: SourceRange | None = None

    #: Parsed longhand components of this property if it is a shorthand.
    #: This field will be empty if the given property is not a shorthand.
    longhand_properties: list[CSSProperty] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['value'] = self.value
        if self.important is not None:
            json['important'] = self.important
        if self.implicit is not None:
            json['implicit'] = self.implicit
        if self.text is not None:
            json['text'] = self.text
        if self.parsed_ok is not None:
            json['parsedOk'] = self.parsed_ok
        if self.disabled is not None:
            json['disabled'] = self.disabled
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.longhand_properties is not None:
            json['longhandProperties'] = [i.to_json() for i in self.longhand_properties]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSProperty:
        return cls(
            name=str(json['name']),
            value=str(json['value']),
            important=None if json.get('important') is None else bool(json['important']),
            implicit=None if json.get('implicit') is None else bool(json['implicit']),
            text=None if json.get('text') is None else str(json['text']),
            parsed_ok=None if json.get('parsedOk') is None else bool(json['parsedOk']),
            disabled=None if json.get('disabled') is None else bool(json['disabled']),
            range_=SourceRange.from_json_optional(json.get('range')),
            longhand_properties=[CSSProperty.from_json(i) for i in json.get('longhandProperties', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSProperty | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSMedia:
    """
    CSS media rule descriptor.
    """

    #: Media query text.
    text: str

    #: Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
    #: specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
    #: stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
    #: stylesheet's STYLE tag.
    source: str

    #: URL of the document containing the media query description.
    source_url: str | None = None

    #: The associated rule (@media or @import) header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    #: Array of media queries.
    media_list: list[MediaQuery] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        json['source'] = self.source
        if self.source_url is not None:
            json['sourceURL'] = self.source_url
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.media_list is not None:
            json['mediaList'] = [i.to_json() for i in self.media_list]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSMedia:
        return cls(
            text=str(json['text']),
            source=str(json['source']),
            source_url=None if json.get('sourceURL') is None else str(json['sourceURL']),
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
            media_list=[MediaQuery.from_json(i) for i in json.get('mediaList', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSMedia | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class MediaQuery:
    """
    Media query descriptor.
    """

    #: Array of media query expressions.
    expressions: list[MediaQueryExpression]

    #: Whether the media query condition is satisfied.
    active: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['expressions'] = [i.to_json() for i in self.expressions]
        json['active'] = self.active
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> MediaQuery:
        return cls(
            expressions=[MediaQueryExpression.from_json(i) for i in json.get('expressions', [])],
            active=bool(json['active']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> MediaQuery | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class MediaQueryExpression:
    """
    Media query expression descriptor.
    """

    #: Media query expression value.
    value: float

    #: Media query expression units.
    unit: str

    #: Media query expression feature.
    feature: str

    #: The associated range of the value text in the enclosing stylesheet (if available).
    value_range: SourceRange | None = None

    #: Computed length of media query expression (if applicable).
    computed_length: float | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['value'] = self.value
        json['unit'] = self.unit
        json['feature'] = self.feature
        if self.value_range is not None:
            json['valueRange'] = self.value_range.to_json()
        if self.computed_length is not None:
            json['computedLength'] = self.computed_length
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> MediaQueryExpression:
        return cls(
            value=float(json['value']),
            unit=str(json['unit']),
            feature=str(json['feature']),
            value_range=SourceRange.from_json_optional(json.get('valueRange')),
            computed_length=None if json.get('computedLength') is None else float(json['computedLength']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> MediaQueryExpression | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSContainerQuery:
    """
    CSS container query rule descriptor.
    """

    #: Container query text.
    text: str

    #: The associated rule header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    #: Optional name for the container.
    name: str | None = None

    #: Optional physical axes queried for the container.
    physical_axes: dom.PhysicalAxes | None = None

    #: Optional logical axes queried for the container.
    logical_axes: dom.LogicalAxes | None = None

    #: true if the query contains scroll-state() queries.
    queries_scroll_state: bool | None = None

    #: true if the query contains anchored() queries.
    queries_anchored: bool | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.name is not None:
            json['name'] = self.name
        if self.physical_axes is not None:
            json['physicalAxes'] = self.physical_axes.to_json()
        if self.logical_axes is not None:
            json['logicalAxes'] = self.logical_axes.to_json()
        if self.queries_scroll_state is not None:
            json['queriesScrollState'] = self.queries_scroll_state
        if self.queries_anchored is not None:
            json['queriesAnchored'] = self.queries_anchored
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSContainerQuery:
        return cls(
            text=str(json['text']),
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
            name=None if json.get('name') is None else str(json['name']),
            physical_axes=dom.PhysicalAxes.from_json_optional(json.get('physicalAxes')),
            logical_axes=dom.LogicalAxes.from_json_optional(json.get('logicalAxes')),
            queries_scroll_state=None if json.get('queriesScrollState') is None else bool(json['queriesScrollState']),
            queries_anchored=None if json.get('queriesAnchored') is None else bool(json['queriesAnchored']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSContainerQuery | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSSupports:
    """
    CSS Supports at-rule descriptor.
    """

    #: Supports rule text.
    text: str

    #: Whether the supports condition is satisfied.
    active: bool

    #: The associated rule header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        json['active'] = self.active
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSSupports:
        return cls(
            text=str(json['text']),
            active=bool(json['active']),
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSSupports | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSScope:
    """
    CSS Scope at-rule descriptor.
    """

    #: Scope rule text.
    text: str

    #: The associated rule header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSScope:
        return cls(
            text=str(json['text']),
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSScope | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSLayer:
    """
    CSS Layer at-rule descriptor.
    """

    #: Layer name.
    text: str

    #: The associated rule header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['text'] = self.text
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSLayer:
        return cls(
            text=str(json['text']),
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSLayer | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSStartingStyle:
    """
    CSS Starting Style at-rule descriptor.
    """

    #: The associated rule header range in the enclosing stylesheet (if
    #: available).
    range_: SourceRange | None = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.range_ is not None:
            json['range'] = self.range_.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSStartingStyle:
        return cls(
            range_=SourceRange.from_json_optional(json.get('range')),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSStartingStyle | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSLayerData:
    """
    CSS Layer data.
    """

    #: Layer name.
    name: str

    #: Layer order. The order determines the order of the layer in the cascade order.
    #: A higher number has higher priority in the cascade order.
    order: float

    #: Direct sub-layers
    sub_layers: list[CSSLayerData] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['order'] = self.order
        if self.sub_layers is not None:
            json['subLayers'] = [i.to_json() for i in self.sub_layers]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSLayerData:
        return cls(
            name=str(json['name']),
            order=float(json['order']),
            sub_layers=[CSSLayerData.from_json(i) for i in json.get('subLayers', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSLayerData | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PlatformFontUsage:
    """
    Information about amount of glyphs that were rendered with given font.
    """

    #: Font's family name reported by platform.
    family_name: str

    #: Font's PostScript name reported by platform.
    post_script_name: str

    #: Indicates if the font was downloaded or resolved locally.
    is_custom_font: bool

    #: Amount of glyphs that were rendered with this font.
    glyph_count: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['familyName'] = self.family_name
        json['postScriptName'] = self.post_script_name
        json['isCustomFont'] = self.is_custom_font
        json['glyphCount'] = self.glyph_count
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlatformFontUsage:
        return cls(
            family_name=str(json['familyName']),
            post_script_name=str(json['postScriptName']),
            is_custom_font=bool(json['isCustomFont']),
            glyph_count=float(json['glyphCount']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlatformFontUsage | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class FontVariationAxis:
    """
    Information about font variation axes for variable fonts
    """

    #: The font-variation-setting tag (a.k.a. "axis tag").
    tag: str

    #: Human-readable variation name in the default language (normally, "en").
    name: str

    #: The minimum value (inclusive) the font supports for this tag.
    min_value: float

    #: The maximum value (inclusive) the font supports for this tag.
    max_value: float

    #: The default value.
    default_value: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['tag'] = self.tag
        json['name'] = self.name
        json['minValue'] = self.min_value
        json['maxValue'] = self.max_value
        json['defaultValue'] = self.default_value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FontVariationAxis:
        return cls(
            tag=str(json['tag']),
            name=str(json['name']),
            min_value=float(json['minValue']),
            max_value=float(json['maxValue']),
            default_value=float(json['defaultValue']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> FontVariationAxis | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class FontFace:
    """
    Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    and additional information such as platformFontFamily and fontVariationAxes.
    """

    #: The font-family.
    font_family: str

    #: The font-style.
    font_style: str

    #: The font-variant.
    font_variant: str

    #: The font-weight.
    font_weight: str

    #: The font-stretch.
    font_stretch: str

    #: The font-display.
    font_display: str

    #: The unicode-range.
    unicode_range: str

    #: The src.
    src: str

    #: The resolved platform font family
    platform_font_family: str

    #: Available variation settings (a.k.a. "axes").
    font_variation_axes: list[FontVariationAxis] = field(default_factory=list)

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['fontFamily'] = self.font_family
        json['fontStyle'] = self.font_style
        json['fontVariant'] = self.font_variant
        json['fontWeight'] = self.font_weight
        json['fontStretch'] = self.font_stretch
        json['fontDisplay'] = self.font_display
        json['unicodeRange'] = self.unicode_range
        json['src'] = self.src
        json['platformFontFamily'] = self.platform_font_family
        if self.font_variation_axes is not None:
            json['fontVariationAxes'] = [i.to_json() for i in self.font_variation_axes]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FontFace:
        return cls(
            font_family=str(json['fontFamily']),
            font_style=str(json['fontStyle']),
            font_variant=str(json['fontVariant']),
            font_weight=str(json['fontWeight']),
            font_stretch=str(json['fontStretch']),
            font_display=str(json['fontDisplay']),
            unicode_range=str(json['unicodeRange']),
            src=str(json['src']),
            platform_font_family=str(json['platformFontFamily']),
            font_variation_axes=[FontVariationAxis.from_json(i) for i in json.get('fontVariationAxes', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> FontFace | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSTryRule:
    """
    CSS try rule representation.
    """

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['origin'] = self.origin.to_json()
        json['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSTryRule:
        return cls(
            origin=StyleSheetOrigin.from_json(json['origin']),
            style=CSSStyle.from_json(json['style']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSTryRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSPositionTryRule:
    """
    CSS @position-try rule representation.
    """

    #: The prelude dashed-ident name
    name: Value

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated style declaration.
    style: CSSStyle

    active: bool

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name.to_json()
        json['origin'] = self.origin.to_json()
        json['style'] = self.style.to_json()
        json['active'] = self.active
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSPositionTryRule:
        return cls(
            name=Value.from_json(json['name']),
            origin=StyleSheetOrigin.from_json(json['origin']),
            style=CSSStyle.from_json(json['style']),
            active=bool(json['active']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSPositionTryRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSKeyframesRule:
    """
    CSS keyframes rule representation.
    """

    #: Animation name.
    animation_name: Value

    #: List of keyframes.
    keyframes: list[CSSKeyframeRule]

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['animationName'] = self.animation_name.to_json()
        json['keyframes'] = [i.to_json() for i in self.keyframes]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSKeyframesRule:
        return cls(
            animation_name=Value.from_json(json['animationName']),
            keyframes=[CSSKeyframeRule.from_json(i) for i in json.get('keyframes', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSKeyframesRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSPropertyRegistration:
    """
    Representation of a custom property registration through CSS.registerProperty
    """

    property_name: str

    inherits: bool

    syntax: str

    initial_value: Value | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['propertyName'] = self.property_name
        json['inherits'] = self.inherits
        json['syntax'] = self.syntax
        if self.initial_value is not None:
            json['initialValue'] = self.initial_value.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSPropertyRegistration:
        return cls(
            property_name=str(json['propertyName']),
            inherits=bool(json['inherits']),
            syntax=str(json['syntax']),
            initial_value=Value.from_json_optional(json.get('initialValue')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSPropertyRegistration | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSFontPaletteValuesRule:
    """
    CSS font-palette-values rule representation.
    """

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated font palette name.
    font_palette_name: Value

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['origin'] = self.origin.to_json()
        json['fontPaletteName'] = self.font_palette_name.to_json()
        json['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSFontPaletteValuesRule:
        return cls(
            origin=StyleSheetOrigin.from_json(json['origin']),
            font_palette_name=Value.from_json(json['fontPaletteName']),
            style=CSSStyle.from_json(json['style']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSFontPaletteValuesRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSPropertyRule:
    """
    CSS property at-rule representation.
    """

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated property name.
    property_name: Value

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['origin'] = self.origin.to_json()
        json['propertyName'] = self.property_name.to_json()
        json['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSPropertyRule:
        return cls(
            origin=StyleSheetOrigin.from_json(json['origin']),
            property_name=Value.from_json(json['propertyName']),
            style=CSSStyle.from_json(json['style']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSPropertyRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSFunctionParameter:
    """
    CSS function argument representation.
    """

    #: The parameter name.
    name: str

    #: The parameter type.
    type_: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['type'] = self.type_
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSFunctionParameter:
        return cls(
            name=str(json['name']),
            type_=str(json['type']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSFunctionParameter | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSFunctionConditionNode:
    """
    CSS function conditional block representation.
    """

    #: Block body.
    children: list[CSSFunctionNode]

    #: The condition text.
    condition_text: str

    #: Media query for this conditional block. Only one type of condition should be set.
    media: CSSMedia | None = None

    #: Container query for this conditional block. Only one type of condition should be set.
    container_queries: CSSContainerQuery | None = None

    #: @supports CSS at-rule condition. Only one type of condition should be set.
    supports: CSSSupports | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['children'] = [i.to_json() for i in self.children]
        json['conditionText'] = self.condition_text
        if self.media is not None:
            json['media'] = self.media.to_json()
        if self.container_queries is not None:
            json['containerQueries'] = self.container_queries.to_json()
        if self.supports is not None:
            json['supports'] = self.supports.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSFunctionConditionNode:
        return cls(
            children=[CSSFunctionNode.from_json(i) for i in json.get('children', [])],
            condition_text=str(json['conditionText']),
            media=CSSMedia.from_json_optional(json.get('media')),
            container_queries=CSSContainerQuery.from_json_optional(json.get('containerQueries')),
            supports=CSSSupports.from_json_optional(json.get('supports')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSFunctionConditionNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSFunctionNode:
    """
    Section of the body of a CSS function rule.
    """

    #: A conditional block. If set, style should not be set.
    condition: CSSFunctionConditionNode | None = None

    #: Values set by this node. If set, condition should not be set.
    style: CSSStyle | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        if self.condition is not None:
            json['condition'] = self.condition.to_json()
        if self.style is not None:
            json['style'] = self.style.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSFunctionNode:
        return cls(
            condition=CSSFunctionConditionNode.from_json_optional(json.get('condition')),
            style=CSSStyle.from_json_optional(json.get('style')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSFunctionNode | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSFunctionRule:
    """
    CSS function at-rule representation.
    """

    #: Name of the function.
    name: Value

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: List of parameters.
    parameters: list[CSSFunctionParameter]

    #: Function body.
    children: list[CSSFunctionNode]

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name.to_json()
        json['origin'] = self.origin.to_json()
        json['parameters'] = [i.to_json() for i in self.parameters]
        json['children'] = [i.to_json() for i in self.children]
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSFunctionRule:
        return cls(
            name=Value.from_json(json['name']),
            origin=StyleSheetOrigin.from_json(json['origin']),
            parameters=[CSSFunctionParameter.from_json(i) for i in json.get('parameters', [])],
            children=[CSSFunctionNode.from_json(i) for i in json.get('children', [])],
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSFunctionRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class CSSKeyframeRule:
    """
    CSS keyframe rule representation.
    """

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated key text.
    key_text: Value

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['origin'] = self.origin.to_json()
        json['keyText'] = self.key_text.to_json()
        json['style'] = self.style.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CSSKeyframeRule:
        return cls(
            origin=StyleSheetOrigin.from_json(json['origin']),
            key_text=Value.from_json(json['keyText']),
            style=CSSStyle.from_json(json['style']),
            style_sheet_id=StyleSheetId.from_json_optional(json.get('styleSheetId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> CSSKeyframeRule | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class StyleDeclarationEdit:
    """
    A descriptor of operation to mutate style declaration text.
    """

    #: The css style sheet identifier.
    style_sheet_id: StyleSheetId

    #: The range of the style text in the enclosing stylesheet.
    range_: SourceRange

    #: New style text.
    text: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['styleSheetId'] = self.style_sheet_id.to_json()
        json['range'] = self.range_.to_json()
        json['text'] = self.text
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StyleDeclarationEdit:
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            range_=SourceRange.from_json(json['range']),
            text=str(json['text']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> StyleDeclarationEdit | None:
        if json is None:
            return None
        return cls.from_json(json)


def add_rule(
    style_sheet_id: StyleSheetId,
    rule_text: str,
    location: SourceRange,
    *,
    node_for_property_syntax_validation: dom.NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSRule]:
    """
    Inserts a new rule with the given ``ruleText`` in a stylesheet with given ``styleSheetId``, at the
    position specified by ``location``.

    :param style_sheet_id: The css style sheet identifier where a new rule should be inserted.
    :param rule_text: The text of a new rule.
    :param location: Text position of a new rule in the target style sheet.
    :param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSRule]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['ruleText'] = rule_text
    params['location'] = location.to_json()
    if node_for_property_syntax_validation is not None:
        params['nodeForPropertySyntaxValidation'] = node_for_property_syntax_validation.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.addRule',
        'params': params,
    }
    json = yield cmd_dict
    return CSSRule.from_json(json['rule'])


def collect_class_names(
    style_sheet_id: StyleSheetId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Returns all class names from specified stylesheet.

    :param style_sheet_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[str]]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.collectClassNames',
        'params': params,
    }
    json = yield cmd_dict
    return [str(i) for i in json.get('classNames', [])]


def create_style_sheet(
    frame_id: page.FrameId,
    *,
    force: bool | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, StyleSheetId]:
    """
    Creates a new special "via-inspector" stylesheet in the frame with given ``frameId``.

    :param frame_id: Identifier of the frame where "via-inspector" stylesheet should be created.
    :param force: *(Optional)* If true, creates a new stylesheet for every call. If false, returns a stylesheet previously created by a call with force=false for the frame's document if it exists or creates a new stylesheet (default: false).
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, StyleSheetId]
    """

    params: T_JSON_DICT = {}
    params['frameId'] = frame_id.to_json()
    if force is not None:
        params['force'] = force
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.createStyleSheet',
        'params': params,
    }
    json = yield cmd_dict
    return StyleSheetId.from_json(json['styleSheetId'])


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables the CSS agent for the given page.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.disable',
    }
    json = yield cmd_dict


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
    enabled until the result of this command is received.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.enable',
    }
    json = yield cmd_dict


def force_pseudo_state(
    node_id: dom.NodeId,
    forced_pseudo_classes: list[str],
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Ensures that the given node will have specified pseudo-classes whenever its style is computed by
    the browser.

    :param node_id: The element id for which to force the pseudo state.
    :param forced_pseudo_classes: Element pseudo classes to force when computing the element's style.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    params['forcedPseudoClasses'] = forced_pseudo_classes
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.forcePseudoState',
        'params': params,
    }
    json = yield cmd_dict


def force_starting_style(
    node_id: dom.NodeId,
    *,
    forced: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Ensures that the given node is in its starting-style state.

    :param node_id: The element id for which to force the starting-style state.
    :param forced: Boolean indicating if this is on or off.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    params['forced'] = forced
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.forceStartingStyle',
        'params': params,
    }
    json = yield cmd_dict


def get_background_colors(
    node_id: dom.NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[str] | None, str | None, str | None]]:
    """
    :param node_id: Id of the node to get background colors for.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[str] `` None, str `` None, str ` None]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getBackgroundColors',
        'params': params,
    }
    json = yield cmd_dict
    return (
        [str(i) for i in json.get('backgroundColors', [])],
        None if json.get('computedFontSize') is None else str(json['computedFontSize']),
        None if json.get('computedFontWeight') is None else str(json['computedFontWeight']),
    )


def get_computed_style_for_node(
    node_id: dom.NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CSSComputedStyleProperty], ComputedStyleExtraFields]]:
    """
    Returns the computed style for a DOM node identified by ``nodeId``.

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CSSComputedStyleProperty], ComputedStyleExtraFields]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getComputedStyleForNode',
        'params': params,
    }
    json = yield cmd_dict
    return (
        [CSSComputedStyleProperty.from_json(i) for i in json.get('computedStyle', [])],
        ComputedStyleExtraFields.from_json(json['extraFields']),
    )


def resolve_values(
    values: list[str],
    node_id: dom.NodeId,
    *,
    property_name: str | None = None,
    pseudo_type: dom.PseudoType | None = None,
    pseudo_identifier: str | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[str]]:
    """
    Resolve the specified values in the context of the provided element.
    For example, a value of '1em' is evaluated according to the computed
    'font-size' of the element and a value 'calc(1px + 2px)' will be
    resolved to '3px'.
    If the ``propertyName`` was specified the ``values`` are resolved as if
    they were property's declaration. If a value cannot be parsed according
    to the provided property syntax, the value is parsed using combined
    syntax as if null ``propertyName`` was provided. If the value cannot be
    resolved even then, return the provided value without any changes.

    **EXPERIMENTAL**

    :param values: Cascade-dependent keywords (revert/revert-layer) do not work.
    :param node_id: Id of the node in whose context the expression is evaluated
    :param property_name: *(Optional)* Only longhands and custom property names are accepted.
    :param pseudo_type: *(Optional)* Pseudo element type, only works for pseudo elements that generate elements in the tree, such as ::before and ::after.
    :param pseudo_identifier: *(Optional)* Pseudo element custom ident.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[str]]
    """

    params: T_JSON_DICT = {}
    params['values'] = values
    params['nodeId'] = node_id.to_json()
    if property_name is not None:
        params['propertyName'] = property_name
    if pseudo_type is not None:
        params['pseudoType'] = pseudo_type.to_json()
    if pseudo_identifier is not None:
        params['pseudoIdentifier'] = pseudo_identifier
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.resolveValues',
        'params': params,
    }
    json = yield cmd_dict
    return [str(i) for i in json.get('results', [])]


def get_longhand_properties(
    shorthand_name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[CSSProperty]]:
    """


    **EXPERIMENTAL**

    :param shorthand_name:
    :param value:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[CSSProperty]]
    """

    params: T_JSON_DICT = {}
    params['shorthandName'] = shorthand_name
    params['value'] = value
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getLonghandProperties',
        'params': params,
    }
    json = yield cmd_dict
    return [CSSProperty.from_json(i) for i in json.get('longhandProperties', [])]


def get_inline_styles_for_node(
    node_id: dom.NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[CSSStyle | None, CSSStyle | None]]:
    """
    Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
    attributes) for a DOM node identified by ``nodeId``.

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[CSSStyle `` None, CSSStyle `` None]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getInlineStylesForNode',
        'params': params,
    }
    json = yield cmd_dict
    return (
        CSSStyle.from_json_optional(json.get('inlineStyle')),
        CSSStyle.from_json_optional(json.get('attributesStyle')),
    )


def get_animated_styles_for_node(
    node_id: dom.NodeId,
) -> Generator[
    T_JSON_DICT,
    T_JSON_DICT,
    tuple[list[CSSAnimationStyle] | None, CSSStyle | None, list[InheritedAnimatedStyleEntry] | None],
]:
    """
    Returns the styles coming from animations & transitions
    including the animation & transition styles coming from inheritance chain.

    **EXPERIMENTAL**

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CSSAnimationStyle] `` None, CSSStyle `` None, list[InheritedAnimatedStyleEntry] ` None]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getAnimatedStylesForNode',
        'params': params,
    }
    json = yield cmd_dict
    return (
        [CSSAnimationStyle.from_json(i) for i in json.get('animationStyles', [])],
        CSSStyle.from_json_optional(json.get('transitionsStyle')),
        [InheritedAnimatedStyleEntry.from_json(i) for i in json.get('inherited', [])],
    )


def get_matched_styles_for_node(
    node_id: dom.NodeId,
) -> Generator[
    T_JSON_DICT,
    T_JSON_DICT,
    tuple[
        CSSStyle | None,
        CSSStyle | None,
        list[RuleMatch] | None,
        list[PseudoElementMatches] | None,
        list[InheritedStyleEntry] | None,
        list[InheritedPseudoElementMatches] | None,
        list[CSSKeyframesRule] | None,
        list[CSSPositionTryRule] | None,
        int | None,
        list[CSSPropertyRule] | None,
        list[CSSPropertyRegistration] | None,
        CSSFontPaletteValuesRule | None,
        dom.NodeId | None,
        list[CSSFunctionRule] | None,
    ],
]:
    """
    Returns requested styles for a DOM node identified by ``nodeId``.

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[CSSStyle `` None, CSSStyle `` None, list[RuleMatch] `` None, list[PseudoElementMatches] `` None, list[InheritedStyleEntry] `` None, list[InheritedPseudoElementMatches] `` None, list[CSSKeyframesRule] `` None, list[CSSPositionTryRule] `` None, int `` None, list[CSSPropertyRule] `` None, list[CSSPropertyRegistration] `` None, CSSFontPaletteValuesRule `` None, dom.NodeId `` None, list[CSSFunctionRule] `` None]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getMatchedStylesForNode',
        'params': params,
    }
    json = yield cmd_dict
    return (
        CSSStyle.from_json_optional(json.get('inlineStyle')),
        CSSStyle.from_json_optional(json.get('attributesStyle')),
        [RuleMatch.from_json(i) for i in json.get('matchedCSSRules', [])],
        [PseudoElementMatches.from_json(i) for i in json.get('pseudoElements', [])],
        [InheritedStyleEntry.from_json(i) for i in json.get('inherited', [])],
        [InheritedPseudoElementMatches.from_json(i) for i in json.get('inheritedPseudoElements', [])],
        [CSSKeyframesRule.from_json(i) for i in json.get('cssKeyframesRules', [])],
        [CSSPositionTryRule.from_json(i) for i in json.get('cssPositionTryRules', [])],
        None if json.get('activePositionFallbackIndex') is None else int(json['activePositionFallbackIndex']),
        [CSSPropertyRule.from_json(i) for i in json.get('cssPropertyRules', [])],
        [CSSPropertyRegistration.from_json(i) for i in json.get('cssPropertyRegistrations', [])],
        CSSFontPaletteValuesRule.from_json_optional(json.get('cssFontPaletteValuesRule')),
        dom.NodeId.from_json_optional(json.get('parentLayoutNodeId')),
        [CSSFunctionRule.from_json(i) for i in json.get('cssFunctionRules', [])],
    )


def get_environment_variables() -> Generator[T_JSON_DICT, T_JSON_DICT, dict]:
    """
    Returns the values of the default UA-defined environment variables used in env()

    **EXPERIMENTAL**

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, dict]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getEnvironmentVariables',
    }
    json = yield cmd_dict
    return dict(json['environmentVariables'])


def get_media_queries() -> Generator[T_JSON_DICT, T_JSON_DICT, list[CSSMedia]]:
    """
    Returns all media queries parsed by the rendering engine.

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[CSSMedia]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getMediaQueries',
    }
    json = yield cmd_dict
    return [CSSMedia.from_json(i) for i in json.get('medias', [])]


def get_platform_fonts_for_node(
    node_id: dom.NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[PlatformFontUsage]]:
    """
    Requests information about platform fonts which we used to render child TextNodes in the given
    node.

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[PlatformFontUsage]]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getPlatformFontsForNode',
        'params': params,
    }
    json = yield cmd_dict
    return [PlatformFontUsage.from_json(i) for i in json.get('fonts', [])]


def get_style_sheet_text(
    style_sheet_id: StyleSheetId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str]:
    """
    Returns the current textual content for a stylesheet.

    :param style_sheet_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, str]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getStyleSheetText',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['text'])


def get_layers_for_node(
    node_id: dom.NodeId,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSLayerData]:
    """
    Returns all layers parsed by the rendering engine for the tree scope of a node.
    Given a DOM element identified by nodeId, getLayersForNode returns the root
    layer for the nearest ancestor document or shadow root. The layer root contains
    the full layer tree for the tree scope and their ordering.

    **EXPERIMENTAL**

    :param node_id:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSLayerData]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getLayersForNode',
        'params': params,
    }
    json = yield cmd_dict
    return CSSLayerData.from_json(json['rootLayer'])


def get_location_for_selector(
    style_sheet_id: StyleSheetId,
    selector_text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[SourceRange]]:
    """
    Given a CSS selector text and a style sheet ID, getLocationForSelector
    returns an array of locations of the CSS selector in the style sheet.

    **EXPERIMENTAL**

    :param style_sheet_id:
    :param selector_text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[SourceRange]]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['selectorText'] = selector_text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getLocationForSelector',
        'params': params,
    }
    json = yield cmd_dict
    return [SourceRange.from_json(i) for i in json.get('ranges', [])]


def track_computed_style_updates_for_node(
    node_id: dom.NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Starts tracking the given node for the computed style updates
    and whenever the computed style is updated for node, it queues
    a ``computedStyleUpdated`` event with throttling.
    There can only be 1 node tracked for computed style updates
    so passing a new node id removes tracking from the previous node.
    Pass ``undefined`` to disable tracking.

    **EXPERIMENTAL**

    :param node_id: *(Optional)*
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    if node_id is not None:
        params['nodeId'] = node_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.trackComputedStyleUpdatesForNode',
        'params': params,
    }
    json = yield cmd_dict


def track_computed_style_updates(
    properties_to_track: list[CSSComputedStyleProperty],
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Starts tracking the given computed styles for updates. The specified array of properties
    replaces the one previously specified. Pass empty array to disable tracking.
    Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
    The changes to computed style properties are only tracked for nodes pushed to the front-end
    by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
    to the front-end, no updates will be issued for the node.

    **EXPERIMENTAL**

    :param properties_to_track:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['propertiesToTrack'] = [i.to_json() for i in properties_to_track]
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.trackComputedStyleUpdates',
        'params': params,
    }
    json = yield cmd_dict


def take_computed_style_updates() -> Generator[T_JSON_DICT, T_JSON_DICT, list[dom.NodeId]]:
    """
    Polls the next batch of computed style updates.

    **EXPERIMENTAL**

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[dom.NodeId]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.takeComputedStyleUpdates',
    }
    json = yield cmd_dict
    return [dom.NodeId.from_json(i) for i in json.get('nodeIds', [])]


def set_effective_property_value_for_node(
    node_id: dom.NodeId,
    property_name: str,
    value: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Find a rule with the given active property for the given node and set the new value for this
    property

    :param node_id: The element id for which to set property.
    :param property_name:
    :param value:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['nodeId'] = node_id.to_json()
    params['propertyName'] = property_name
    params['value'] = value
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setEffectivePropertyValueForNode',
        'params': params,
    }
    json = yield cmd_dict


def set_property_rule_property_name(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    property_name: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Value]:
    """
    Modifies the property rule property name.

    :param style_sheet_id:
    :param range_:
    :param property_name:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, Value]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['propertyName'] = property_name
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setPropertyRulePropertyName',
        'params': params,
    }
    json = yield cmd_dict
    return Value.from_json(json['propertyName'])


def set_keyframe_key(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    key_text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, Value]:
    """
    Modifies the keyframe rule key text.

    :param style_sheet_id:
    :param range_:
    :param key_text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, Value]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['keyText'] = key_text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setKeyframeKey',
        'params': params,
    }
    json = yield cmd_dict
    return Value.from_json(json['keyText'])


def set_media_text(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSMedia]:
    """
    Modifies the rule selector.

    :param style_sheet_id:
    :param range_:
    :param text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSMedia]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['text'] = text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setMediaText',
        'params': params,
    }
    json = yield cmd_dict
    return CSSMedia.from_json(json['media'])


def set_container_query_text(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSContainerQuery]:
    """
    Modifies the expression of a container query.

    **EXPERIMENTAL**

    :param style_sheet_id:
    :param range_:
    :param text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSContainerQuery]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['text'] = text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setContainerQueryText',
        'params': params,
    }
    json = yield cmd_dict
    return CSSContainerQuery.from_json(json['containerQuery'])


def set_supports_text(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSSupports]:
    """
    Modifies the expression of a supports at-rule.

    **EXPERIMENTAL**

    :param style_sheet_id:
    :param range_:
    :param text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSSupports]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['text'] = text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setSupportsText',
        'params': params,
    }
    json = yield cmd_dict
    return CSSSupports.from_json(json['supports'])


def set_scope_text(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, CSSScope]:
    """
    Modifies the expression of a scope at-rule.

    **EXPERIMENTAL**

    :param style_sheet_id:
    :param range_:
    :param text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, CSSScope]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['text'] = text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setScopeText',
        'params': params,
    }
    json = yield cmd_dict
    return CSSScope.from_json(json['scope'])


def set_rule_selector(
    style_sheet_id: StyleSheetId,
    range_: SourceRange,
    selector: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, SelectorList]:
    """
    Modifies the rule selector.

    :param style_sheet_id:
    :param range_:
    :param selector:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, SelectorList]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['range'] = range_.to_json()
    params['selector'] = selector
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setRuleSelector',
        'params': params,
    }
    json = yield cmd_dict
    return SelectorList.from_json(json['selectorList'])


def set_style_sheet_text(
    style_sheet_id: StyleSheetId,
    text: str,
) -> Generator[T_JSON_DICT, T_JSON_DICT, str | None]:
    """
    Sets the new stylesheet text.

    :param style_sheet_id:
    :param text:
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, str ` None]
    """

    params: T_JSON_DICT = {}
    params['styleSheetId'] = style_sheet_id.to_json()
    params['text'] = text
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setStyleSheetText',
        'params': params,
    }
    json = yield cmd_dict
    return None if json.get('sourceMapURL') is None else str(json['sourceMapURL'])


def set_style_texts(
    edits: list[StyleDeclarationEdit],
    *,
    node_for_property_syntax_validation: dom.NodeId | None = None,
) -> Generator[T_JSON_DICT, T_JSON_DICT, list[CSSStyle]]:
    """
    Applies specified style edits one after another in the given order.

    :param edits:
    :param node_for_property_syntax_validation: **(EXPERIMENTAL)** *(Optional)* NodeId for the DOM node in whose context custom property declarations for registered properties should be validated. If omitted, declarations in the new rule text can only be validated statically, which may produce incorrect results if the declaration contains a var() for example.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[CSSStyle]]
    """

    params: T_JSON_DICT = {}
    params['edits'] = [i.to_json() for i in edits]
    if node_for_property_syntax_validation is not None:
        params['nodeForPropertySyntaxValidation'] = node_for_property_syntax_validation.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setStyleTexts',
        'params': params,
    }
    json = yield cmd_dict
    return [CSSStyle.from_json(i) for i in json.get('styles', [])]


def start_rule_usage_tracking() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables the selector recording.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.startRuleUsageTracking',
    }
    json = yield cmd_dict


def stop_rule_usage_tracking() -> Generator[T_JSON_DICT, T_JSON_DICT, list[RuleUsage]]:
    """
    Stop tracking rule usage and return the list of rules that were used since last call to
    ``takeCoverageDelta`` (or since start of coverage instrumentation).

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, list[RuleUsage]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.stopRuleUsageTracking',
    }
    json = yield cmd_dict
    return [RuleUsage.from_json(i) for i in json.get('ruleUsage', [])]


def take_coverage_delta() -> Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[RuleUsage], float]]:
    """
    Obtain list of rules that became used since last call to this method (or since start of coverage
    instrumentation).

    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[RuleUsage], float]]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.takeCoverageDelta',
    }
    json = yield cmd_dict
    return ([RuleUsage.from_json(i) for i in json.get('coverage', [])], float(json['timestamp']))


def set_local_fonts_enabled(
    *,
    enabled: bool,
) -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables/disables rendering of local CSS fonts (enabled by default).

    **EXPERIMENTAL**

    :param enabled: Whether rendering of local fonts is enabled.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    params: T_JSON_DICT = {}
    params['enabled'] = enabled
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setLocalFontsEnabled',
        'params': params,
    }
    json = yield cmd_dict


@event_type('CSS.fontsUpdated')
@dataclass
class FontsUpdated:
    """
    Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
    web font.
    """

    #: The web font that has loaded.
    font: FontFace | None

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> FontsUpdated:
        return cls(font=FontFace.from_json_optional(json.get('font')))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> FontsUpdated | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('CSS.mediaQueryResultChanged')
@dataclass
class MediaQueryResultChanged:
    """
    Fires whenever a MediaQuery result changes (for example, after a browser window has been
    resized.) The current implementation considers only viewport-dependent media features.
    """

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> MediaQueryResultChanged:
        return cls()

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> MediaQueryResultChanged | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('CSS.styleSheetAdded')
@dataclass
class StyleSheetAdded:
    """
    Fired whenever an active document stylesheet is added.
    """

    #: Added stylesheet metainfo.
    header: CSSStyleSheetHeader

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StyleSheetAdded:
        return cls(header=CSSStyleSheetHeader.from_json(json['header']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> StyleSheetAdded | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('CSS.styleSheetChanged')
@dataclass
class StyleSheetChanged:
    """
    Fired whenever a stylesheet is changed as a result of the client operation.
    """

    style_sheet_id: StyleSheetId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StyleSheetChanged:
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> StyleSheetChanged | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('CSS.styleSheetRemoved')
@dataclass
class StyleSheetRemoved:
    """
    Fired whenever an active document stylesheet is removed.
    """

    #: Identifier of the removed stylesheet.
    style_sheet_id: StyleSheetId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> StyleSheetRemoved:
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> StyleSheetRemoved | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('CSS.computedStyleUpdated')
@dataclass
class ComputedStyleUpdated:
    """
    **EXPERIMENTAL**


    """

    #: The node id that has updated computed styles.
    node_id: dom.NodeId

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ComputedStyleUpdated:
        return cls(node_id=dom.NodeId.from_json(json['nodeId']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> ComputedStyleUpdated | None:
        if json is None:
            return None
        return cls.from_json(json)
