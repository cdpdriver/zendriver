# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate all of the modules.
#
# Specification verion: 1.3
#
#
# CDP domain: Media (experimental)

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

from . import dom
from .util import event_type


if TYPE_CHECKING:
    from collections.abc import Generator

    from .util import T_JSON_DICT


# ruff: noqa: FURB189


class PlayerId(str):
    """
    Players will get an ID that is unique within the agent context.
    """

    __slots__ = ()

    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> PlayerId:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: str | None) -> PlayerId | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'PlayerId({super().__repr__()})'


class Timestamp(float):
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> Timestamp:
        return cls(json)

    @classmethod
    def from_json_optional(cls, json: float | None) -> Timestamp | None:
        if json is None:
            return None
        return cls.from_json(json)

    def __repr__(self) -> str:
        return f'Timestamp({super().__repr__()})'


@dataclass
class PlayerMessage:
    """
    Have one type per entry in MediaLogRecord::Type
    Corresponds to kMessage
    """

    #: Keep in sync with MediaLogMessageLevel
    #: We are currently keeping the message level 'error' separate from the
    #: PlayerError type because right now they represent different things,
    #: this one being a DVLOG(ERROR) style log message that gets printed
    #: based on what log level is selected in the UI, and the other is a
    #: representation of a media::PipelineStatus object. Soon however we're
    #: going to be moving away from using PipelineStatus for errors and
    #: introducing a new error type which should hopefully let us integrate
    #: the error log level into the PlayerError type.
    level: str

    message: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['level'] = self.level
        json['message'] = self.message
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerMessage:
        return cls(
            level=str(json['level']),
            message=str(json['message']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerMessage | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PlayerProperty:
    """
    Corresponds to kMediaPropertyChange
    """

    name: str

    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['name'] = self.name
        json['value'] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerProperty:
        return cls(
            name=str(json['name']),
            value=str(json['value']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerProperty | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PlayerEvent:
    """
    Corresponds to kMediaEventTriggered
    """

    timestamp: Timestamp

    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['timestamp'] = self.timestamp.to_json()
        json['value'] = self.value
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerEvent:
        return cls(
            timestamp=Timestamp.from_json(json['timestamp']),
            value=str(json['value']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerEvent | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PlayerErrorSourceLocation:
    """
    Represents logged source line numbers reported in an error.
    NOTE: file and line are from chromium c++ implementation code, not js.
    """

    file: str

    line: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['file'] = self.file
        json['line'] = self.line
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerErrorSourceLocation:
        return cls(
            file=str(json['file']),
            line=int(json['line']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerErrorSourceLocation | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class PlayerError:
    """
    Corresponds to kMediaError
    """

    error_type: str

    #: Code is the numeric enum entry for a specific set of error codes, such
    #: as PipelineStatusCodes in media/base/pipeline_status.h
    code: int

    #: A trace of where this error was caused / where it passed through.
    stack: list[PlayerErrorSourceLocation]

    #: Errors potentially have a root cause error, ie, a DecoderError might be
    #: caused by an WindowsError
    cause: list[PlayerError]

    #: Extra data attached to an error, such as an HRESULT, Video Codec, etc.
    data: dict

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['errorType'] = self.error_type
        json['code'] = self.code
        json['stack'] = [i.to_json() for i in self.stack]
        json['cause'] = [i.to_json() for i in self.cause]
        json['data'] = self.data
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerError:
        return cls(
            error_type=str(json['errorType']),
            code=int(json['code']),
            stack=[PlayerErrorSourceLocation.from_json(i) for i in json.get('stack', [])],
            cause=[PlayerError.from_json(i) for i in json.get('cause', [])],
            data=dict(json['data']),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerError | None:
        if json is None:
            return None
        return cls.from_json(json)


@dataclass
class Player:
    player_id: PlayerId

    dom_node_id: dom.BackendNodeId | None = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {}
        json['playerId'] = self.player_id.to_json()
        if self.dom_node_id is not None:
            json['domNodeId'] = self.dom_node_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Player:
        return cls(
            player_id=PlayerId.from_json(json['playerId']),
            dom_node_id=dom.BackendNodeId.from_json_optional(json.get('domNodeId')),
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> Player | None:
        if json is None:
            return None
        return cls.from_json(json)


def enable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Enables the Media domain
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Media.enable',
    }
    json = yield cmd_dict


def disable() -> Generator[T_JSON_DICT, T_JSON_DICT]:
    """
    Disables the Media domain.
    :returns: A generator
    :rtype: Generator[T_JSON_DICT, T_JSON_DICT]
    """

    cmd_dict: T_JSON_DICT = {
        'method': 'Media.disable',
    }
    json = yield cmd_dict


@event_type('Media.playerPropertiesChanged')
@dataclass
class PlayerPropertiesChanged:
    """
    This can be called multiple times, and can be used to set / override /
    remove player properties. A null propValue indicates removal.
    """

    player_id: PlayerId
    properties: list[PlayerProperty]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerPropertiesChanged:
        return cls(
            player_id=PlayerId.from_json(json['playerId']),
            properties=[PlayerProperty.from_json(i) for i in json.get('properties', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerPropertiesChanged | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Media.playerEventsAdded')
@dataclass
class PlayerEventsAdded:
    """
    Send events as a list, allowing them to be batched on the browser for less
    congestion. If batched, events must ALWAYS be in chronological order.
    """

    player_id: PlayerId
    events: list[PlayerEvent]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerEventsAdded:
        return cls(
            player_id=PlayerId.from_json(json['playerId']),
            events=[PlayerEvent.from_json(i) for i in json.get('events', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerEventsAdded | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Media.playerMessagesLogged')
@dataclass
class PlayerMessagesLogged:
    """
    Send a list of any messages that need to be delivered.
    """

    player_id: PlayerId
    messages: list[PlayerMessage]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerMessagesLogged:
        return cls(
            player_id=PlayerId.from_json(json['playerId']),
            messages=[PlayerMessage.from_json(i) for i in json.get('messages', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerMessagesLogged | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Media.playerErrorsRaised')
@dataclass
class PlayerErrorsRaised:
    """
    Send a list of any errors that need to be delivered.
    """

    player_id: PlayerId
    errors: list[PlayerError]

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerErrorsRaised:
        return cls(
            player_id=PlayerId.from_json(json['playerId']),
            errors=[PlayerError.from_json(i) for i in json.get('errors', [])],
        )

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerErrorsRaised | None:
        if json is None:
            return None
        return cls.from_json(json)


@event_type('Media.playerCreated')
@dataclass
class PlayerCreated:
    """
    Called whenever a player is created, or when a new agent joins and receives
    a list of active players. If an agent is restored, it will receive one
    event for each active player.
    """

    player: Player

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> PlayerCreated:
        return cls(player=Player.from_json(json['player']))

    @classmethod
    def from_json_optional(cls, json: T_JSON_DICT | None) -> PlayerCreated | None:
        if json is None:
            return None
        return cls.from_json(json)
